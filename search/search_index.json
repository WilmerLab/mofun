{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MOFUN Installation Requires Python > 3.8. pip install mofun Command-line usage: mofun {input-structure} {output-structure} -f {find-pattern} -r {replace-pattern} mofun --help Tue Jan 18 12:00:59 2022 Usage: mofun [OPTIONS] INPUTPATH OUTPUTPATH Options: -f, --find PATH -r, --replace PATH -p, --replace-fraction FLOAT --atol FLOAT absolute tolerance in Angstroms for atom posistions to be considered matching -ap1, --axisp1-idx INTEGER index of first point on primary rotation axis -ap2, --axisp2-idx INTEGER index of second point on primary rotation axis -op, --opoint-idx INTEGER index of point that makes up secondary rotation axis (between this point and the primary rotation axis) --dumppath PATH -q, --chargefile FILENAME --replicate INTEGER... replicate structure across x, y, and z dimensions --mic FLOAT enforce minimum image convention using a cutoff of mic --framework-element TEXT convert all atoms that are in group 0, the framework group to a specific atom type to make vizualizing the structure easier --pp Assign UFF pair potentials to atoms (sufficient for fixed force-field calculations) --help Show this message and exit. Pyrhon documentation: See Atoms for info on Atoms objects and how to use them. See mofun for find_pattern_in_structure() and replace_pattern_in_structure(). See Examples for full examples on real systems, using both the command line and the Python interfaces.","title":"MOFUN"},{"location":"#mofun","text":"","title":"MOFUN"},{"location":"#installation","text":"Requires Python > 3.8. pip install mofun","title":"Installation"},{"location":"#command-line-usage","text":"mofun {input-structure} {output-structure} -f {find-pattern} -r {replace-pattern} mofun --help Tue Jan 18 12:00:59 2022 Usage: mofun [OPTIONS] INPUTPATH OUTPUTPATH Options: -f, --find PATH -r, --replace PATH -p, --replace-fraction FLOAT --atol FLOAT absolute tolerance in Angstroms for atom posistions to be considered matching -ap1, --axisp1-idx INTEGER index of first point on primary rotation axis -ap2, --axisp2-idx INTEGER index of second point on primary rotation axis -op, --opoint-idx INTEGER index of point that makes up secondary rotation axis (between this point and the primary rotation axis) --dumppath PATH -q, --chargefile FILENAME --replicate INTEGER... replicate structure across x, y, and z dimensions --mic FLOAT enforce minimum image convention using a cutoff of mic --framework-element TEXT convert all atoms that are in group 0, the framework group to a specific atom type to make vizualizing the structure easier --pp Assign UFF pair potentials to atoms (sufficient for fixed force-field calculations) --help Show this message and exit.","title":"Command-line usage:"},{"location":"#pyrhon-documentation","text":"See Atoms for info on Atoms objects and how to use them. See mofun for find_pattern_in_structure() and replace_pattern_in_structure(). See Examples for full examples on real systems, using both the command line and the Python interfaces.","title":"Pyrhon documentation:"},{"location":"examples/","text":"Examples Supporting files for all examples can be found in the main repo at docs/examples/. Example 1: functionalizing a MOF For this example, we will take the UiO-66 MOF and functionalize its linker with a hydroxyl group. We have provided all the files for this example, but if you were do this procedure on your own structure, you would need to take the following steps: Prepare the structure file as a P1 CIF or a P1 LAMMPS data file. Prepare the search pattern. In this example, we are searching for the linker of UiO-66, which is a biphenyl linker. We used Vesta to pick one linker in the structure, deleted all other atoms, then exported to a file format that Avogadro can read. We opened the file in Avogadro and saved as CML. Prepare the replacement pattern. The replacement pattern needs to lie in the same coordinate system as the search pattern. The easiest way to do this is to start with the search pattern and simply not move any of the atoms unless you want to move them with the replacement operation. For this example, we took the search pattern CML, replaced one of the hydrogens on the biphenyl group with an oxygen atom, and added the attached hydrogen to make the hydroxyl. We used avogadro's \"fix atoms\" feature to fix all the atoms except for the newly added ones, then ran optimize structure to let the OH group find a more appropriate position. (Note that if you do not fix ALL the atoms except for the hydroxyls, many of the atoms will move when you optimize and the atoms of your replacement pattern may insert into an odd position!) Search pattern: UiO-66 linker Replacement pattern: UiO-66 linker with hydroxyl functional group Once you have the files prepared, the find / replace operation is very simple. In Python: from mofun import Atoms , replace_pattern_in_structure structure = Atoms . load ( \"uio66.cif\" ) uio66_linker = Atoms . load ( \"uio66-linker.cml\" ) uio66_linker_oh = Atoms . load ( \"uio66-linker-oh.cml\" ) structure_oh = replace_pattern_in_structure ( structure , uio66_linker , uio66_linker_oh ) structure_oh . save ( \"uio66-oh.lmpdat\" ) In your shell: mofun uio66.cif uio66-oh.cif --find uio66-linker.cml --replace uio66-linker-oh.cml If you look in the output uio66-oh.cif file, you will see the hydroxyls on all the linkers. UiO-66 with hydroxyls Example 2: introducing defects into a MOF For this example, we will introduce defects into UiO-66 by randomly removing linkers from the structure. We will first replicate the structure to a 2x2x2 so it fulfills minimum image conventions. We do this before adding defects, so that the defects aren't repeated in the structure. We will create defects for 10%, and 90% of all linkers. (Clearly, having 90% of linkers be defective would create a non-viable structure, but it is easier to visualize). As in example 1, we will need to prepare the structure file, search pattern and replacement pattern. See above for discussion on how we typically do that. We can use the structure and search pattern files from example 1, but we will need a replacement pattern where the biphenyl ring is removed and there are formate caps where the linker would attach to the metal center. Replacement pattern: UiO-66 defective linker In Python: from mofun import Atoms , replace_pattern_in_structure structure = Atoms . load ( \"uio66.cif\" ) . replicate (( 2 , 2 , 2 )) uio66_linker = Atoms . load ( \"uio66-linker.cml\" ) uio66_linker_defective = Atoms . load ( \"uio66-linker-defective.cml\" ) defective10 = replace_pattern_in_structure ( structure , uio66_linker , uio66_linker_defective , replace_fraction = 0.10 ) defective10 . to_ase () . write ( \"uio66-defective-10.cif\" ) defective90 = replace_pattern_in_structure ( structure , uio66_linker , uio66_linker_defective , replace_fraction = 0.90 ) defective90 . to_ase () . write ( \"uio66-defective-90.cif\" ) In your shell: mofun uio66.cif uio66-defective-10.cif -f uio66-linker.cml -r uio66-linker-defective.cml --replicate 2 2 2 --replace-fraction = 0 .10 mofun uio66.cif uio66-defective-90.cif -f uio66-linker.cml -r uio66-linker-defective.cml --replicate 2 2 2 --replace-fraction = 0 .90 Structure with 90% defects Example 3: parameterizing a replicated MOF using only parameterized linker and metal centers For this example, we start with an unparameterized CIF file, and then we find and replace both the linker and the metal center with parameterized versions, thus parameterizing the full structure across periodic boundaries. For this to work, you will need to have overlapping patterns; the parameterized linker and the parameterized metal center will share some atoms. This is necessary to define 3-body (angle) or 4-body (dihedral, improper) force field terms near the edge of the pattern. If you have only two-body terms (i.e. bond) then the patterns only need to share the atom that connects the metal center to the linker (so that all bonds are defined); if you have three-body terms, then an extra atom will need to be shared; for four-body terms, another extra atom will be shared between the patterns. Prepare parameterized linker and metal center LAMMPS data files. In Python: from mofun import Atoms , replace_pattern_in_structure structure = Atoms . load ( \"uio66.cif\" ) uio66_linker = Atoms . load ( \"uio66-linker-Zr.cml\" ) uio66_linker_params = Atoms . load ( \"uio66-linker-Zr-parameterized.lmpdat\" ) uio66_mc = Atoms . load ( \"uio66-metal-center.cml\" ) uio66_mc_params = Atoms . load ( \"uio66-metal-center-parameterized.lmpdat\" ) param1 = replace_pattern_in_structure ( structure , uio66_mc , uio66_mc_params ) param2 = replace_pattern_in_structure ( param1 , uio66_linker , uio66_linker_params ) param2 . save ( \"uio66-parameterized.lmpdat\" ) In your shell: mofun uio66.cif uio66-param1.lmpdat --find uio66-metal-center.cml \\ --replace uio66-metal-center-parameterized.lmpdat mofun uio66-param1.lmpdat uio66-parameterized.lmpdat --find uio66-linker-Zr.cml \\ --replace uio66-linker-Zr-parameterized.lmpdat While we use separate files above for clarity, it is also possible to use the parameterized files for both the search and replace patterns, like this: mofun uio66.cif uio66-param1.lmpdat --find uio66-metal-center-parameterized.lmpdat \\ --replace uio66-metal-center-parameterized.lmpdat mofun uio66-param1.lmpdat uio66-parameterized.lmpdat --find uio66-linker-Zr-parameterized.lmpdat \\ --replace uio66-linker-Zr-parameterized.lmpdat This may be confusing at first glance, since we are finding the same pattern that we are replacing it with. However, the find operation only looks at the positions of the atoms (and does not require that the force field terms match); for the replace operation, all the atom positions stay the same but the appropriate force field terms are inserted. To evaluate whether the final structure is valid, you will need to look at the resulting LAMMPS data file and check the connectivity and the force field terms, since visually, the structure will look identical.","title":"Examples"},{"location":"examples/#examples","text":"Supporting files for all examples can be found in the main repo at docs/examples/.","title":"Examples"},{"location":"examples/#example-1-functionalizing-a-mof","text":"For this example, we will take the UiO-66 MOF and functionalize its linker with a hydroxyl group. We have provided all the files for this example, but if you were do this procedure on your own structure, you would need to take the following steps: Prepare the structure file as a P1 CIF or a P1 LAMMPS data file. Prepare the search pattern. In this example, we are searching for the linker of UiO-66, which is a biphenyl linker. We used Vesta to pick one linker in the structure, deleted all other atoms, then exported to a file format that Avogadro can read. We opened the file in Avogadro and saved as CML. Prepare the replacement pattern. The replacement pattern needs to lie in the same coordinate system as the search pattern. The easiest way to do this is to start with the search pattern and simply not move any of the atoms unless you want to move them with the replacement operation. For this example, we took the search pattern CML, replaced one of the hydrogens on the biphenyl group with an oxygen atom, and added the attached hydrogen to make the hydroxyl. We used avogadro's \"fix atoms\" feature to fix all the atoms except for the newly added ones, then ran optimize structure to let the OH group find a more appropriate position. (Note that if you do not fix ALL the atoms except for the hydroxyls, many of the atoms will move when you optimize and the atoms of your replacement pattern may insert into an odd position!) Search pattern: UiO-66 linker Replacement pattern: UiO-66 linker with hydroxyl functional group Once you have the files prepared, the find / replace operation is very simple. In Python: from mofun import Atoms , replace_pattern_in_structure structure = Atoms . load ( \"uio66.cif\" ) uio66_linker = Atoms . load ( \"uio66-linker.cml\" ) uio66_linker_oh = Atoms . load ( \"uio66-linker-oh.cml\" ) structure_oh = replace_pattern_in_structure ( structure , uio66_linker , uio66_linker_oh ) structure_oh . save ( \"uio66-oh.lmpdat\" ) In your shell: mofun uio66.cif uio66-oh.cif --find uio66-linker.cml --replace uio66-linker-oh.cml If you look in the output uio66-oh.cif file, you will see the hydroxyls on all the linkers. UiO-66 with hydroxyls","title":"Example 1: functionalizing a MOF"},{"location":"examples/#example-2-introducing-defects-into-a-mof","text":"For this example, we will introduce defects into UiO-66 by randomly removing linkers from the structure. We will first replicate the structure to a 2x2x2 so it fulfills minimum image conventions. We do this before adding defects, so that the defects aren't repeated in the structure. We will create defects for 10%, and 90% of all linkers. (Clearly, having 90% of linkers be defective would create a non-viable structure, but it is easier to visualize). As in example 1, we will need to prepare the structure file, search pattern and replacement pattern. See above for discussion on how we typically do that. We can use the structure and search pattern files from example 1, but we will need a replacement pattern where the biphenyl ring is removed and there are formate caps where the linker would attach to the metal center. Replacement pattern: UiO-66 defective linker In Python: from mofun import Atoms , replace_pattern_in_structure structure = Atoms . load ( \"uio66.cif\" ) . replicate (( 2 , 2 , 2 )) uio66_linker = Atoms . load ( \"uio66-linker.cml\" ) uio66_linker_defective = Atoms . load ( \"uio66-linker-defective.cml\" ) defective10 = replace_pattern_in_structure ( structure , uio66_linker , uio66_linker_defective , replace_fraction = 0.10 ) defective10 . to_ase () . write ( \"uio66-defective-10.cif\" ) defective90 = replace_pattern_in_structure ( structure , uio66_linker , uio66_linker_defective , replace_fraction = 0.90 ) defective90 . to_ase () . write ( \"uio66-defective-90.cif\" ) In your shell: mofun uio66.cif uio66-defective-10.cif -f uio66-linker.cml -r uio66-linker-defective.cml --replicate 2 2 2 --replace-fraction = 0 .10 mofun uio66.cif uio66-defective-90.cif -f uio66-linker.cml -r uio66-linker-defective.cml --replicate 2 2 2 --replace-fraction = 0 .90 Structure with 90% defects","title":"Example 2: introducing defects into a MOF"},{"location":"examples/#example-3-parameterizing-a-replicated-mof-using-only-parameterized-linker-and-metal-centers","text":"For this example, we start with an unparameterized CIF file, and then we find and replace both the linker and the metal center with parameterized versions, thus parameterizing the full structure across periodic boundaries. For this to work, you will need to have overlapping patterns; the parameterized linker and the parameterized metal center will share some atoms. This is necessary to define 3-body (angle) or 4-body (dihedral, improper) force field terms near the edge of the pattern. If you have only two-body terms (i.e. bond) then the patterns only need to share the atom that connects the metal center to the linker (so that all bonds are defined); if you have three-body terms, then an extra atom will need to be shared; for four-body terms, another extra atom will be shared between the patterns. Prepare parameterized linker and metal center LAMMPS data files. In Python: from mofun import Atoms , replace_pattern_in_structure structure = Atoms . load ( \"uio66.cif\" ) uio66_linker = Atoms . load ( \"uio66-linker-Zr.cml\" ) uio66_linker_params = Atoms . load ( \"uio66-linker-Zr-parameterized.lmpdat\" ) uio66_mc = Atoms . load ( \"uio66-metal-center.cml\" ) uio66_mc_params = Atoms . load ( \"uio66-metal-center-parameterized.lmpdat\" ) param1 = replace_pattern_in_structure ( structure , uio66_mc , uio66_mc_params ) param2 = replace_pattern_in_structure ( param1 , uio66_linker , uio66_linker_params ) param2 . save ( \"uio66-parameterized.lmpdat\" ) In your shell: mofun uio66.cif uio66-param1.lmpdat --find uio66-metal-center.cml \\ --replace uio66-metal-center-parameterized.lmpdat mofun uio66-param1.lmpdat uio66-parameterized.lmpdat --find uio66-linker-Zr.cml \\ --replace uio66-linker-Zr-parameterized.lmpdat While we use separate files above for clarity, it is also possible to use the parameterized files for both the search and replace patterns, like this: mofun uio66.cif uio66-param1.lmpdat --find uio66-metal-center-parameterized.lmpdat \\ --replace uio66-metal-center-parameterized.lmpdat mofun uio66-param1.lmpdat uio66-parameterized.lmpdat --find uio66-linker-Zr-parameterized.lmpdat \\ --replace uio66-linker-Zr-parameterized.lmpdat This may be confusing at first glance, since we are finding the same pattern that we are replacing it with. However, the find operation only looks at the positions of the atoms (and does not require that the force field terms match); for the replace operation, all the atom positions stay the same but the appropriate force field terms are inserted. To evaluate whether the final structure is valid, you will need to look at the resulting LAMMPS data file and check the connectivity and the force field terms, since visually, the structure will look identical.","title":"Example 3: parameterizing a replicated MOF using only parameterized linker and metal centers"},{"location":"reference/atoms/","text":"Atoms An Atoms object is a container for all the information required to keep track of a structure and the structure's force field. See the documentation on __init__ or load to see how to create an Atoms object. An Atoms object is made up primarily of numpy arrays and a couple normal lists. Some arrays are per-atom (one entry per atom): atom_types , positions , charges , and groups . Some arrays are per-atom-type (one entry per atom type): atom_type_masses , atom_type_elements , and atom_type_labels . Some arrays are per-bond (one entry per bond): bonds , and bond_types . Some arrays are per-angle (one entry per angle): angles , and angle_types . Some arrays are per-dihedral (one entry per dihedral): dihedrals , and dihedral_types . Some arrays are per-improper (one entry per improper): impropers , and improper_types . Atoms also stores information on the coefficients needed to define each force field term: pair_coeffs , bond_type_coeffs , angle_type_coeffs , dihedral_type_coeffs , and improper_type_coeffs . The *_coeffs variables are lists of strings, where the item index corresponds to the *_type, and the string is the full LAMMPS coeffs definition string. we do not interpret any of the LAMMPS coefficient specifics, we just store it in its original form, i.e. this Angle Coeffs section: Angle Coeffs 1 cosine/periodic 72.500283 -1 1 # C_R O_1 H_ 2 cosine/periodic 277.164705 -1 3 # C_R C_R O_1 would be interpreted like this: angle_type_coeffs= [\"cosine/periodic 72.500283 -1 1 # C_R O_1 H_\", \"cosine/periodic 277.164705 -1 3 # C_R C_R O_1\"] __init__ ( self , atom_types = [], positions = [], charges = [], groups = [], elements = [], atom_type_masses = [], atom_type_elements = [], atom_type_labels = [], bonds = [], bond_types = [], angles = [], angle_types = [], dihedrals = [], dihedral_types = [], impropers = [], improper_types = [], pair_coeffs = [], bond_type_coeffs = [], angle_type_coeffs = [], dihedral_type_coeffs = [], improper_type_coeffs = [], cell = None ) special Create an Atoms object. An Atoms object can be created without any atoms using Atoms() . For creating more interesting Atoms objects, there are a few rules to keep in mind. The parameters atom_types , positions , charges , and groups are all lists that should have a size equal to the number of atoms in the system. positions is mandatory; charges , and groups are optional (both default to 0 for each atom) and there are two ways to specify atom types: 1) specify the atom_types and atom_type_elements explicitly, which is how the load_lmpdat method loads Atoms objects from a LAMMPS data file, or 2) specify per-atom elements and and have MOFUN auto-number the atom types for you, which is more convenient when specifying small molecules in code or when loading from other file formats such as CML or CIF which may store element information but not type information. When explicitly setting the types, you must pass atom_types and atom_type_elements . atom_types is a list of int type ids >= 0, one for each atom in the system. atom_type_elements is a list of element names (e.g. \"C\", \"N\", \"Zr\") per atom type . For example, if your system is propane, your atom_types list could be [0, 1, 1, 1] and your atom_type_elements list would then be [\"C\", \"H\"]. To specify per-atom elements, you must pass elements with either a list of elements, such as Atoms(elements=[\"C\", \"C\"], ...) or with a string Atoms(elements=\"CC\", ...) . If you use the elements parameter, then type ids are automatically generated. Passing atom_type_masses is optional, and masses will be inferred from the elements if missing. If you are using atom types with masses that do not correspond to periodic table elements, then you will need to specify the masses explicitly. Passing force field term information for bonds , angles , dihedrals , and impropers is optional, as well as passing force field coefficients for LAMMPS with pair_coeffs , bond_type_coeffs , angle_type_coeffs , dihedral_type_coeffs , and improper_type_coeffs . Examples: a = Atoms() # create an empty Atoms object with no atoms a = Atoms(atom_types=[0], positions=[[0,0,0]]) # create one atom of type 0 a = Atoms(elements=[\"C\"], positions=[[0,0,0]]) # create one Carbon a = Atoms(elements=[\"C\", \"C\"], positions=[[0,0,0], [1,0,0]]) # create two Carbons a = Atoms(elements=\"CC\", positions=[[0,0,0], [1,0,0]]) # create two Carbons using shorthand element notation Parameters: Name Type Description Default atom_types List[int] list of integer type ids, one per atom. [] positions List[Tuple[float, float, float]] list of tuple atom x,y,z coordinates, one per atom. [] charges List[float] list of charges, one per atom. Defaults to 0 for each atom if not passed. [] groups List[int] list of integer groups, one per atom. For LAMMPS this gets mapped to a \"molecule id\". Defaults to 0 for each atom if not passed. [] elements List[str], str either a list of elements, (e.g. [\"C\", \"H\", \"H\", \"H\"]) or an element string (e.g. \"CHHH\") [] atom_type_masses List[float] list of atom type masses, one per atom type. If masses are not passed, they will be inferred from the atom_type_elements . [] atom_type_elements List[str] list of atom type elements, one per atom type. [] atom_type_labels List[str] list of atom type labels, one per atom type. Used in LAMMPS data file line comments as type labels. [] bonds List[Tuple[int, int]] list of bond tuples where each tuple defines a pair of atoms that are bonded. Each value in the tuple is an index of an atom in the atom_* lists. [] bond_types List[int] list of bond type id ints for each bond defined in bonds . [] angles List[Tuple[int, int, int]] list of angle tuples where each tuple defines a triplet of atoms making up the angle. Each value in the tuple is an index of an atom in the atom_* lists. [] angle_types List[int] list of angle type id ints for each angle defined in angles . [] dihedrals List[Tuple[int, int, int, int]] list of dihedral tuples where each dihedral defines a quartet of atoms making up the dihedral. Each value in the tuple is an index of an atom in the atom_* lists. [] dihedral_types List[int] list of dihedral type id ints for each dihedral defined in dihedrals . [] impropers List[Tuple[int, int, int, int]] list of improper tuples where each improper defines a quartet of atoms making up the improper. Each value in the tuple is an index of an atom in the atom_* lists. [] improper_types List[int] list of improper type id ints for each improper defined in impropers . [] pair_coeffs List[str] pair coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per atom type. [] bond_type_coeffs List[str] bond coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per bond type. [] angle_type_coeffs List[str] angle coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per angle type. [] dihedral_type_coeffs List[str] dihedral coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per dihedral type. [] improper_type_coeffs List[str] improper coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per improper type. [] cell Array(3x3 3x3 array of unit cell vectors. None Returns: Type Description Atoms the atoms object. Source code in mofun/atoms.py def __init__ ( self , atom_types = [], positions = [], charges = [], groups = [], elements = [], atom_type_masses = [], atom_type_elements = [], atom_type_labels = [], bonds = [], bond_types = [], angles = [], angle_types = [], dihedrals = [], dihedral_types = [], impropers = [], improper_types = [], pair_coeffs = [], bond_type_coeffs = [], angle_type_coeffs = [], dihedral_type_coeffs = [], improper_type_coeffs = [], cell = None ): \"\"\"Create an Atoms object. An Atoms object can be created without any atoms using `Atoms()`. For creating more interesting Atoms objects, there are a few rules to keep in mind. The parameters `atom_types`, `positions`, `charges`, and `groups` are all lists that should have a size equal to the number of atoms in the system. `positions` is mandatory; `charges`, and `groups` are optional (both default to 0 for each atom) and there are two ways to specify atom types: 1) specify the atom_types and atom_type_elements explicitly, which is how the `load_lmpdat` method loads Atoms objects from a LAMMPS data file, or 2) specify per-atom elements and and have MOFUN auto-number the atom types for you, which is more convenient when specifying small molecules in code or when loading from other file formats such as CML or CIF which may store element information but not type information. When explicitly setting the types, you must pass `atom_types` and `atom_type_elements`. `atom_types` is a list of int type ids >= 0, one for each atom in the system. `atom_type_elements` is a list of element names (e.g. \"C\", \"N\", \"Zr\") per _atom type_. For example, if your system is propane, your atom_types list could be [0, 1, 1, 1] and your atom_type_elements list would then be [\"C\", \"H\"]. To specify per-atom elements, you must pass `elements` with either a list of elements, such as `Atoms(elements=[\"C\", \"C\"], ...)` or with a string `Atoms(elements=\"CC\", ...)`. If you use the `elements` parameter, then type ids are automatically generated. Passing `atom_type_masses` is optional, and masses will be inferred from the elements if missing. If you are using atom types with masses that do not correspond to periodic table elements, then you will need to specify the masses explicitly. Passing force field term information for `bonds`, `angles`, `dihedrals`, and `impropers` is optional, as well as passing force field coefficients for LAMMPS with `pair_coeffs`, `bond_type_coeffs`, `angle_type_coeffs`, `dihedral_type_coeffs`, and `improper_type_coeffs`. Examples: ``` a = Atoms() # create an empty Atoms object with no atoms a = Atoms(atom_types=[0], positions=[[0,0,0]]) # create one atom of type 0 a = Atoms(elements=[\"C\"], positions=[[0,0,0]]) # create one Carbon a = Atoms(elements=[\"C\", \"C\"], positions=[[0,0,0], [1,0,0]]) # create two Carbons a = Atoms(elements=\"CC\", positions=[[0,0,0], [1,0,0]]) # create two Carbons using shorthand element notation ``` Args: atom_types (List[int]): list of integer type ids, one per atom. positions (List[Tuple[float, float, float]]): list of tuple atom x,y,z coordinates, one per atom. charges (List[float]): list of charges, one per atom. Defaults to 0 for each atom if not passed. groups (List[int]): list of integer groups, one per atom. For LAMMPS this gets mapped to a \"molecule id\". Defaults to 0 for each atom if not passed. elements (List[str], str): either a list of elements, (e.g. [\"C\", \"H\", \"H\", \"H\"]) or an element string (e.g. \"CHHH\") atom_type_masses (List[float]): list of atom type masses, one per atom type. If masses are not passed, they will be inferred from the `atom_type_elements`. atom_type_elements (List[str]): list of atom type elements, one per atom type. atom_type_labels (List[str]): list of atom type labels, one per atom type. Used in LAMMPS data file line comments as type labels. bonds (List[Tuple[int, int]]): list of bond tuples where each tuple defines a pair of atoms that are bonded. Each value in the tuple is an index of an atom in the atom_* lists. bond_types (List[int]): list of bond type id ints for each bond defined in `bonds`. angles (List[Tuple[int, int, int]]): list of angle tuples where each tuple defines a triplet of atoms making up the angle. Each value in the tuple is an index of an atom in the atom_* lists. angle_types (List[int]): list of angle type id ints for each angle defined in `angles`. dihedrals (List[Tuple[int, int, int, int]]): list of dihedral tuples where each dihedral defines a quartet of atoms making up the dihedral. Each value in the tuple is an index of an atom in the atom_* lists. dihedral_types (List[int]): list of dihedral type id ints for each dihedral defined in `dihedrals`. impropers (List[Tuple[int, int, int, int]]): list of improper tuples where each improper defines a quartet of atoms making up the improper. Each value in the tuple is an index of an atom in the atom_* lists. improper_types (List[int]): list of improper type id ints for each improper defined in `impropers`. pair_coeffs (List[str]): pair coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per atom type. bond_type_coeffs (List[str]): bond coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per bond type. angle_type_coeffs (List[str]): angle coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per angle type. dihedral_type_coeffs (List[str]): dihedral coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per dihedral type. improper_type_coeffs (List[str]): improper coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per improper type. cell (Array(3x3)): 3x3 array of unit cell vectors. Returns: Atoms: the atoms object. \"\"\" self . atom_type_masses = np . array ( atom_type_masses , ndmin = 1 ) self . positions = np . array ( positions , dtype = float , ndmin = 1 ) if cell is not None : self . cell = np . array ( cell ) else : self . cell = None self . bonds = np . array ( bonds , dtype = int ) self . bond_types = np . array ( bond_types , dtype = int ) self . angles = np . array ( angles , dtype = int ) self . angle_types = np . array ( angle_types , dtype = int ) self . dihedrals = np . array ( dihedrals , dtype = int ) self . dihedral_types = np . array ( dihedral_types , dtype = int ) self . impropers = np . array ( impropers , dtype = int ) self . improper_types = np . array ( improper_types , dtype = int ) self . pair_coeffs = np . array ( pair_coeffs ) self . bond_type_coeffs = np . array ( bond_type_coeffs ) self . angle_type_coeffs = np . array ( angle_type_coeffs ) self . dihedral_type_coeffs = np . array ( dihedral_type_coeffs ) self . improper_type_coeffs = np . array ( improper_type_coeffs ) if len ( charges ) > 0 : self . charges = np . array ( charges , dtype = float ) else : self . charges = np . zeros ( len ( self . positions ), dtype = float ) if len ( groups ) > 0 : self . groups = np . array ( groups , dtype = int ) else : self . groups = np . zeros ( len ( self . positions ), dtype = int ) # load atom_types and atom_type_elements if len ( atom_types ) > 0 : # default case or a __getitem__ subset self . atom_types = np . array ( atom_types ) self . atom_type_elements = atom_type_elements elif len ( elements ) > 0 : # from element array, such as from ASE atoms or read CML # i.e. Propane ['C', 'H', 'H', 'H', 'C', 'H', 'H', 'C', 'H', 'H', 'H']: # or from element string, i.e. Propane \"CHHHCHHCHHH\" (shorthand): if isinstance ( elements , str ): elements = list ( Formula ( elements )) # preserve order of types self . atom_type_elements = list ( dict . fromkeys ( elements ) . keys ()) self . atom_types = np . array ([ self . atom_type_elements . index ( s ) for s in elements ]) else : # no atom_type_elements or elements passed # this should be the `Atoms()` case; if not, it will fail the asserts below self . atom_types = np . array ([], ndmin = 1 ) self . atom_type_elements = [] # automatically determine masses from elements if masses are not passed if len ( self . atom_type_masses ) == 0 and len ( self . atom_type_elements ) > 0 : self . atom_type_masses = [ ATOMIC_MASSES [ s ] for s in self . atom_type_elements ] if len ( atom_type_labels ) > 0 : self . atom_type_labels = atom_type_labels else : print ( \"WARNING: using the atom elements as the atom_type_labels since labels were not supplied.\" , file = sys . stderr ) # use default atom types equal to the element; this may not be unique! self . atom_type_labels = self . atom_type_elements self . assert_arrays_are_consistent_sizes () extend ( self , other , offsets = None , structure_index_map = {}, verbose = False ) Adds other Atoms object's arrays to its own. The default behavior is for all the types and params from other structure to be appended to this structure. Alternatively, an offsets tuple may be passed with the results of calling extend_types(). No new types will be added, but the newly added atoms, bonds, etc will refer to types by their value in the other Atoms object plus the offset. Use this when you are adding the same set of atoms multiple times, or if your other atoms already share the same type ids as this object. For the later case, the tuple (0,0,0,0) may be passed in. Parameters: Name Type Description Default other Atoms atoms to add to self required offsets an offsets tuple with the results of calling extend_types(). None structure_index_map dictionary where key is an index in other and value is an index in self, where entries only exist if the position and element of the entries are identical and can be considered to be the same atom. {} verbose bool print debugging info. False Source code in mofun/atoms.py def extend ( self , other , offsets = None , structure_index_map = {}, verbose = False ): \"\"\"Adds other Atoms object's arrays to its own. The default behavior is for all the types and params from other structure to be appended to this structure. Alternatively, an offsets tuple may be passed with the results of calling extend_types(). No new types will be added, but the newly added atoms, bonds, etc will refer to types by their value in the other Atoms object plus the offset. Use this when you are adding the same set of atoms multiple times, or if your other atoms already share the same type ids as this object. For the later case, the tuple (0,0,0,0) may be passed in. Args: other (Atoms): atoms to add to self offsets: an offsets tuple with the results of calling extend_types(). structure_index_map: dictionary where key is an index in other and value is an index in self, where entries only exist if the position and element of the entries are identical and can be considered to be the same atom. verbose (bool): print debugging info. \"\"\" atom_idx_offset = len ( self . positions ) if offsets is None : if verbose : print ( \"auto offset: extending types\" ) offsets = self . extend_types ( other ) # update atom types for atoms that are already part of self Atoms object for other_index , self_index in structure_index_map . items (): self . atom_types [ self_index ] = other . atom_types [ other_index ] + offsets [ 0 ] # add atoms that are not part of self Atoms object atoms_to_add = [ i for i in range ( len ( other )) if i not in structure_index_map . keys ()] self . positions = np . append ( self . positions , other . positions [ atoms_to_add ], axis = 0 ) self . atom_types = np . append ( self . atom_types , other . atom_types [ atoms_to_add ] + offsets [ 0 ]) self . charges = np . append ( self . charges , other . charges [ atoms_to_add ]) self . groups = np . append ( self . groups , other . groups [ atoms_to_add ]) # update structure index map structure_index_map2 = { a : i + atom_idx_offset for i , a in enumerate ( atoms_to_add )} structure_index_map2 . update ( structure_index_map ) convert2structureindex = np . vectorize ( structure_index_map2 . get ) def find_existing_topo ( topo , new_topo ): \"\"\" find existing topo tuples between the same atoms as a new topo set. Used to allow an override of an existing force field term by finding old terms between the same atoms to delete\"\"\" if len ( topo ) == 0 : return [] return list ( np . nonzero ( cdist ( topo , new_topo , 'cityblock' ) == 0 )[ 0 ]) if len ( other . bonds ) > 0 : new_bonds = convert2structureindex ( other . bonds ) existing_bond_indices = find_existing_topo ( self . bonds , new_bonds ) self . bonds = np . append ( self . bonds , new_bonds ) . reshape (( - 1 , 2 )) self . bond_types = np . append ( self . bond_types , other . bond_types + offsets [ 1 ]) self . bonds = np . delete ( self . bonds , existing_bond_indices , axis = 0 ) self . bond_types = np . delete ( self . bond_types , existing_bond_indices ) if len ( other . angles ) > 0 : new_angles = convert2structureindex ( other . angles ) existing_angle_indices = find_existing_topo ( self . angles , new_angles ) self . angles = np . append ( self . angles , new_angles ) . reshape (( - 1 , 3 )) self . angle_types = np . append ( self . angle_types , other . angle_types + offsets [ 2 ]) self . angles = np . delete ( self . angles , existing_angle_indices , axis = 0 ) self . angle_types = np . delete ( self . angle_types , existing_angle_indices ) if len ( other . dihedrals ) > 0 : new_dihedrals = convert2structureindex ( other . dihedrals ) existing_dihedral_indices = find_existing_topo ( self . dihedrals , new_dihedrals ) self . dihedrals = np . append ( self . dihedrals , new_dihedrals ) . reshape (( - 1 , 4 )) self . dihedral_types = np . append ( self . dihedral_types , other . dihedral_types + offsets [ 3 ]) self . dihedrals = np . delete ( self . dihedrals , existing_dihedral_indices , axis = 0 ) self . dihedral_types = np . delete ( self . dihedral_types , existing_dihedral_indices ) if len ( other . impropers ) > 0 : new_impropers = convert2structureindex ( other . impropers ) existing_improper_indices = find_existing_topo ( self . impropers , new_impropers ) self . impropers = np . append ( self . impropers , new_impropers ) . reshape (( - 1 , 4 )) self . improper_types = np . append ( self . improper_types , other . improper_types + offsets [ 4 ]) self . impropers = np . delete ( self . impropers , existing_improper_indices , axis = 0 ) self . improper_types = np . delete ( self . improper_types , existing_improper_indices ) self . assert_arrays_are_consistent_sizes () from_ase_atoms ( atoms ) classmethod Create an Atoms object from an ASE Atoms object. Only supports importing the atom positions, elements, and the unit cell. Parameters: Name Type Description Default atoms ASE Atoms object atoms to load from required Returns: Type Description Atoms atoms loaded from an ASE Atoms object. Source code in mofun/atoms.py @classmethod def from_ase_atoms ( cls , atoms ): \"\"\"Create an Atoms object from an ASE Atoms object. Only supports importing the atom positions, elements, and the unit cell. Args: atoms (ASE Atoms object): atoms to load from Returns: Atoms: atoms loaded from an ASE Atoms object. \"\"\" return cls ( elements = atoms . symbols , positions = atoms . positions , cell = atoms . cell ) load ( f , filetype = None , ** kwargs ) classmethod Creates an Atoms object from either a path or a file object and filetype. Can load any of the supported types: lammps data file: \"lmpdat\" cif cml Parameters: Name Type Description Default f Str or Path or File either a path to a file or an open File to load from required filetype Str filetype ('lmpdat', 'cif', or 'cml') of passed f File object, or explicit filetype to override default filetype implied from file extension. None kwargs keyword args passed on to individual load functions. {} Source code in mofun/atoms.py @classmethod def load ( cls , f , filetype = None , ** kwargs ): \"\"\"Creates an Atoms object from either a path or a file object and filetype. Can load any of the supported types: - lammps data file: \"lmpdat\" - cif - cml Args: f (Str or Path or File): either a path to a file or an open File to load from filetype (Str): filetype ('lmpdat', 'cif', or 'cml') of passed f File object, or explicit filetype to override default filetype implied from file extension. kwargs: keyword args passed on to individual load functions. \"\"\" fd = None path = None if isinstance ( f , io . TextIOBase ): fd = f if filetype is None : raise Exception ( \"If a File object is passed, a filetype must be passed with it\" ) else : # other cases are treated as either Pathlib path or strings path = f if filetype is None : _ , filetype = os . path . splitext ( path ) filetype = filetype [ 1 :] if filetype == \"lmpdat\" : with use_or_open ( fd , path ) as fh : atoms = cls . load_lmpdat ( fh , ** kwargs ) return atoms elif filetype == \"cml\" : return cls . load_cml ( fd or path , ** kwargs ) elif filetype == \"cif\" : with use_or_open ( fd , path ) as fh : return cls . load_cif ( fh , ** kwargs ) else : raise Exception ( \"Unsupported filetype\" ) load_cif ( f ) classmethod Loads a CIF file, including bonding information. Parameters: Name Type Description Default f File File-like object to read from. required Returns: Type Description Atoms loaded Atoms object Source code in mofun/atoms.py @classmethod def load_cif ( cls , f ): \"\"\"Loads a CIF file, including bonding information. Args: f (File): File-like object to read from. Returns: Atoms: loaded Atoms object \"\"\" def has_all_tags ( block , tags ): return np . array ([ block . has_key ( tag ) for tag in tags ]) . all () # PyCifRw supports file descriptors and path strings, but doesn't not support PathLib paths. if isinstance ( f , pathlib . PurePath ): f = str ( f ) cf = read_cif ( f ) block = cf [ cf . get_roots ()[ 0 ][ 0 ]] cart_coord_tags = [ \"_atom_site_Cartn_x\" , \"_atom_site_Cartn_y\" , \"_atom_site_Cartn_z\" , \"_atom_site_label\" ] fract_coord_tags = [ \"_atom_site_fract_x\" , \"_atom_site_fract_y\" , \"_atom_site_fract_z\" , \"_atom_site_label\" ] use_fract_coords = False if has_all_tags ( block , cart_coord_tags ): coords = [ block [ lbl ] for lbl in cart_coord_tags ] elif has_all_tags ( block , fract_coord_tags ): use_fract_coords = True coords = [ block [ lbl ] for lbl in fract_coord_tags ] else : raise ( \"no fractional or cartesian coords in CIF file\" ) x = [ float ( c ) for c in coords [ 0 ]] y = [ float ( c ) for c in coords [ 1 ]] z = [ float ( c ) for c in coords [ 2 ]] atom_name = coords [ 3 ] positions = np . array ([ x , y , z ], dtype = float ) . T atom_types = block [ '_atom_site_type_symbol' ] charges = [] if block . has_key ( '_atom_site_charge' ): charges = block [ '_atom_site_charge' ] bonds = [] bond_tags = [ \"_geom_bond_atom_site_label_1\" , \"_geom_bond_atom_site_label_2\" ] if has_all_tags ( block , bond_tags ): cifbonds = zip ( * [ block [ lbl ] for lbl in bond_tags ]) bonds = [( atom_name . index ( a ), atom_name . index ( b )) for ( a , b ) in cifbonds ] print ( \"WARNING: cif read doesn't handle bond types at present; bonding info is discarded. Use LAMMPS data file format if you need bonds\" , file = sys . stderr ) bonds = [] cell = None cell_tags = [ '_cell_length_a' , '_cell_length_b' , '_cell_length_c' , '_cell_angle_alpha' , '_cell_angle_beta' , '_cell_angle_gamma' ] if has_all_tags ( block , cell_tags ): a , b , c , alpha , beta , gamma = [ float ( block [ tag ]) for tag in cell_tags ] # TODO: Fix for triclinic if alpha != 90. or beta != 90 or gamma != 90. : raise Exception ( \"No support for non orthorhombic UCs at the moment!\" ) cell = np . identity ( 3 ) * ( a , b , c ) if use_fract_coords : positions *= ( a , b , c ) return cls ( elements = atom_types , positions = positions , cell = cell , charges = charges ) load_cml ( f , verbose = False ) classmethod Loads a CML file, including bonding information. Parameters: Name Type Description Default f Path or File Path or File-like object to read from. required Returns: Type Description Atoms loaded Atoms object Source code in mofun/atoms.py @classmethod def load_cml ( cls , f , verbose = False ): \"\"\"Loads a CML file, including bonding information. Args: f (Path or File): Path or File-like object to read from. Returns: Atoms: loaded Atoms object \"\"\" tree = ET . parse ( f ) root = tree . getroot () atom_dicts = [ a . attrib for a in root . findall ( './/atom' )] atom_tuples = [( a [ 'id' ], a [ 'elementType' ], float ( a [ 'x3' ]), float ( a [ 'y3' ]), float ( a [ 'z3' ])) for a in atom_dicts ] ids , elements , x , y , z = zip ( * atom_tuples ) id_to_idx = { id : i for i , id in enumerate ( ids )} positions = np . array ([ x , y , z ]) . T bond_dicts = [ a . attrib for a in root . findall ( './/bond' )] bond_tuples = [( a [ 'atomRefs2' ] . split (), float ( a [ 'order' ])) for a in bond_dicts ] bonds_by_ids , bond_orders = zip ( * bond_tuples ) bonds = [( id_to_idx [ b1 ], id_to_idx [ b2 ]) for ( b1 , b2 ) in bonds_by_ids ] bond_types = [ 0 for b in bonds ] if verbose : print ( \"Found %d atoms: %s \" % ( len ( elements ), elements )) print ( \"Found %d atom positions: %s \" % ( len ( positions ), positions )) print ( \"Found %d bonds: %s \" % ( len ( bonds ), bonds )) print ( \"Found %d bond_types: %s \" % ( len ( bond_types ), bond_types )) return cls ( elements = elements , positions = positions , bonds = bonds , bond_types = bond_types ) load_lmpdat ( f , atom_format = 'full' , guess_atol = 0.1 ) classmethod Load Atoms object from lammps data file (.lmpdat) format. LAMMPS data files store only atom ids and masses, but do not store two other things we need: elements and atom type labels. These are the rules for inferring atom type labels and elements. In priority order, for elements, we: guess the elements using the masses by seeing if there is a periodic table element within 0.1 g/mol of the mass. If any atom types doe not match to an existing periodic table element, this method fails. use the atom ids as the elements (and print a warning). In priority order, for atom type labels, we: use the comments after each line in the Masses section as the atom type. If any line is missing a comment, this method fails. use the elements, if we have them. use the atom ids (and print a warning). Parameters: Name Type Description Default f File File-like object to read from. required atom_format str atom format of lammps data file. Currently supported atom formats are 'full' and 'atomic'. 'full' guess_atol float absolute tolerance a read mass can differ from a periodic table mass and still be considered that element. Default: 0.1. 0.1 Returns: Type Description Atoms loaded Atoms object Source code in mofun/atoms.py @classmethod def load_lmpdat ( cls , f , atom_format = \"full\" , guess_atol = 0.1 ): \"\"\"Load Atoms object from lammps data file (.lmpdat) format. LAMMPS data files store only atom ids and masses, but do not store two other things we need: elements and atom type labels. These are the rules for inferring atom type labels and elements. In priority order, for elements, we: 1. guess the elements using the masses by seeing if there is a periodic table element within 0.1 g/mol of the mass. If any atom types doe not match to an existing periodic table element, this method fails. 2. use the atom ids as the elements (and print a warning). In priority order, for atom type labels, we: 1. use the comments after each line in the Masses section as the atom type. If any line is missing a comment, this method fails. 2. use the elements, if we have them. 3. use the atom ids (and print a warning). Args: f (File): File-like object to read from. atom_format (str): atom format of lammps data file. Currently supported atom formats are 'full' and 'atomic'. guess_atol (float): absolute tolerance a read mass can differ from a periodic table mass and still be considered that element. Default: 0.1. Returns: Atoms: loaded Atoms object \"\"\" def get_types_tups ( arr ): types = tups = [] if len ( arr ) > 0 : types = arr [:, 1 ] - 1 tups = arr [:, 2 :] - 1 return types , tups masses = [] atoms = [] bonds = [] angles = [] dihedrals = [] impropers = [] pair_coeffs = [] bond_coeffs = [] angle_coeffs = [] dihedral_coeffs = [] improper_coeffs = [] atom_type_labels = [] atom_type_elements = [] cellx = celly = cellz = 0.0 sections_handled = [ \"Pair Coeffs\" , \"Bond Coeffs\" , \"Angle Coeffs\" , \"Dihedral Coeffs\" , \"Improper Coeffs\" , \"Atoms\" , \"Bonds\" , \"Angles\" , \"Dihedrals\" , \"Impropers\" , \"Masses\" ] current_section = None start_section = False for unprocessed_line in f : # handle comments comment_string = \"\" comment = None if \"#\" in unprocessed_line : line , comment = unprocessed_line . split ( '#' ) comment = comment . strip () comment_string = \" # \" + comment else : line = unprocessed_line . split ( '#' )[ 0 ] line = line . strip () if line in sections_handled : current_section = line start_section = True continue elif line == \"\" : if not start_section : # end of section or blank current_section = None start_section = False continue tup = line . split () if current_section == \"Masses\" : masses . append ( tup [ 1 ]) atom_type_labels . append ( comment ) elif current_section == \"Pair Coeffs\" : pair_coeffs . append ( \" %s%s \" % ( \" \" . join ( tup [ 1 :]), comment_string )) elif current_section == \"Bond Coeffs\" : bond_coeffs . append ( \" %s%s \" % ( \" \" . join ( tup [ 1 :]), comment_string )) elif current_section == \"Angle Coeffs\" : angle_coeffs . append ( \" %s%s \" % ( \" \" . join ( tup [ 1 :]), comment_string )) elif current_section == \"Dihedral Coeffs\" : dihedral_coeffs . append ( \" %s%s \" % ( \" \" . join ( tup [ 1 :]), comment_string )) elif current_section == \"Improper Coeffs\" : improper_coeffs . append ( \" %s%s \" % ( \" \" . join ( tup [ 1 :]), comment_string )) elif current_section == \"Atoms\" : atoms . append ( tup ) elif current_section == \"Bonds\" : bonds . append ( tup ) elif current_section == \"Angles\" : angles . append ( tup ) elif current_section == \"Dihedrals\" : dihedrals . append ( tup ) elif current_section == \"Impropers\" : impropers . append ( tup ) elif current_section is None : if \"xlo xhi\" in line : cellx = float ( tup [ 1 ]) - float ( tup [ 0 ]) elif \"ylo yhi\" in line : celly = float ( tup [ 1 ]) - float ( tup [ 0 ]) elif \"zlo zhi\" in line : cellz = float ( tup [ 1 ]) - float ( tup [ 0 ]) cell = None if cellx > 0. and celly > 0. and cellz > 0. : cell = np . identity ( 3 ) * ( cellx , celly , cellz ) atom_type_masses = np . array ( masses , dtype = float ) atoms = np . array ( atoms , dtype = float ) bonds = np . array ( bonds , dtype = int ) angles = np . array ( angles , dtype = int ) dihedrals = np . array ( dihedrals , dtype = int ) impropers = np . array ( impropers , dtype = int ) # note: bond indices in lmpdat file are 1-indexed and we are 0-indexed which is why # the bond pairs get a -1 if atom_format == \"atomic\" : atom_types = np . array ( atoms [:, 1 ] - 1 , dtype = int ) groups = np . zeros ( len ( atom_types )) charges = np . zeros ( len ( atom_types )) atom_tups = atoms [:, 2 : 5 ] elif atom_format == \"full\" : groups = np . array ( atoms [:, 1 ] - 1 , dtype = int ) atom_types = np . array ( atoms [:, 2 ] - 1 , dtype = int ) charges = np . array ( atoms [:, 3 ], dtype = float ) atom_tups = atoms [:, 4 : 7 ] # guess the atom elements; if this fails, use the atoms ids as the elements try : atom_type_elements = guess_elements_from_masses ( atom_type_masses , max_delta = guess_atol ) except Exception : print ( \"WARNING: using type ids for elements since some masses do not correspond to periodic table elements within the set tolerance.\" , file = sys . stderr ) atom_type_elements = [ str ( i + 1 ) for i in range ( len ( masses ))] # infer the atom type labels if ( atom_type_labels . count ( None ) == 0 ): # then loading atom types from the labels worked pass else : print ( \"WARNING: using elements for atom type labels since there is not an atom type label comment for every atom type in the Masses section.\" , file = sys . stderr ) atom_type_labels = atom_type_elements . copy () bond_types , bond_tups = get_types_tups ( bonds ) angle_types , angle_tups = get_types_tups ( angles ) dihedral_types , dihedral_tups = get_types_tups ( dihedrals ) improper_types , improper_tups = get_types_tups ( impropers ) return cls ( atom_types = atom_types , positions = atom_tups , charges = charges , atom_type_masses = atom_type_masses , atom_type_elements = atom_type_elements , bond_types = bond_types , bonds = bond_tups , angle_types = angle_types , angles = angle_tups , dihedral_types = dihedral_types , dihedrals = dihedral_tups , improper_types = improper_types , impropers = improper_tups , pair_coeffs = pair_coeffs , bond_type_coeffs = bond_coeffs , angle_type_coeffs = angle_coeffs , dihedral_type_coeffs = dihedral_coeffs , improper_type_coeffs = improper_coeffs , atom_type_labels = atom_type_labels , groups = groups , cell = cell ) replicate ( self , repldims = ( 1 , 1 , 1 )) Replicate atoms object across xyz dimensions Warnings: * does not magically handle any bonds that may cross periodic boundary conditions! Parameters: Name Type Description Default repldims Tuple(int, int, int number of times to replicate in each dimension (1, 1, 1) Returns: Type Description Atoms replicated atoms. Source code in mofun/atoms.py def replicate ( self , repldims = ( 1 , 1 , 1 )): \"\"\"Replicate atoms object across xyz dimensions Warnings: * does not magically handle any bonds that may cross periodic boundary conditions! Args: repldims (Tuple(int, int, int)): number of times to replicate in each dimension Returns: Atoms: replicated atoms. \"\"\" if self . cell is None : raise Exception ( \"Can't replicate if no unit cell has been defined\" ) repl_atoms = self . copy () ucmults = np . array ( np . meshgrid ( * [ range ( r ) for r in repldims ])) . T . reshape ( - 1 , 3 ) ucmults = ucmults [ np . any ( ucmults != 0 , axis = 1 )] # remove [0,0,0] since in copy for ucmult in ucmults : transatoms = self . copy () transatoms . translate ( np . matmul ( transatoms . cell . T , ucmult )) repl_atoms . extend ( transatoms , offsets = ( 0 , 0 , 0 , 0 )) repl_atoms . cell = self . cell * repldims return repl_atoms save ( self , f , filetype = None , ** kwargs ) Saves an Atoms object to either a path or a file object and filetype. Can save any of the supported types: lammps data file: \"lmpdat\" mol Parameters: Name Type Description Default f Str or Path or File either a path to a file or an open File to save to required filetype Str filetype ('lmpdat', 'cif', or 'cml') of passed f File object, or explicit filetype to override default filetype implied from file extension. None kwargs keyword args passed on to individual save functions. {} Source code in mofun/atoms.py def save ( self , f , filetype = None , ** kwargs ): \"\"\"Saves an Atoms object to either a path or a file object and filetype. Can save any of the supported types: - lammps data file: \"lmpdat\" - mol Args: f (Str or Path or File): either a path to a file or an open File to save to filetype (Str): filetype ('lmpdat', 'cif', or 'cml') of passed f File object, or explicit filetype to override default filetype implied from file extension. kwargs: keyword args passed on to individual save functions. \"\"\" fd = None path = None if isinstance ( f , io . TextIOBase ): fd = f if filetype is None : raise Exception ( \"If a File object is passed, a filetype must be passed with it\" ) else : # other cases are treated as either Pathlib path or strings path = f if filetype is None : _ , filetype = os . path . splitext ( path ) filetype = filetype [ 1 :] if filetype == \"lmpdat\" : with use_or_open ( fd , path , mode = 'w' ) as fh : atoms = self . save_lmpdat ( fh , ** kwargs ) return atoms elif filetype == \"mol\" : with use_or_open ( fd , path , mode = 'w' ) as fh : return self . save_mol ( fh , ** kwargs ) else : raise Exception ( \"Unsupported filetype\" ) save_lmpdat ( self , f , atom_format = 'full' , file_comment = '' ) Saves a lmpdat file Parameters: Name Type Description Default f File an open file to write to required atom_format str LAMMPS atom format. Supports only 'atomic' and 'full'. 'full' file_comment str written in first line of output file. '' Source code in mofun/atoms.py def save_lmpdat ( self , f , atom_format = \"full\" , file_comment = \"\" ): \"\"\"Saves a lmpdat file Args: f (File): an open file to write to atom_format (str): LAMMPS atom format. Supports only 'atomic' and 'full'. file_comment (str): written in first line of output file. \"\"\" f . write ( \" %s (written by mofun) \\n\\n \" % file_comment ) f . write ( ' %d atoms \\n ' % len ( self . atom_types )) f . write ( ' %d bonds \\n ' % len ( self . bond_types )) f . write ( ' %d angles \\n ' % len ( self . angle_types )) f . write ( ' %d dihedrals \\n ' % len ( self . dihedral_types )) f . write ( ' %d impropers \\n ' % len ( self . improper_types )) f . write ( \" \\n \" ) if self . num_atom_types > 0 : f . write ( ' %d atom types \\n ' % self . num_atom_types ) if self . num_bond_types > 0 : f . write ( ' %d bond types \\n ' % self . num_bond_types ) if self . num_angle_types > 0 : f . write ( ' %d angle types \\n ' % self . num_angle_types ) if self . num_dihedral_types > 0 : f . write ( ' %d dihedral types \\n ' % self . num_dihedral_types ) if self . num_improper_types > 0 : f . write ( ' %d improper types \\n ' % self . num_improper_types ) # TODO: support triclinic if self . cell is not None and self . cell . shape == ( 3 , 3 ): xlohi , ylohi , zlohi = zip ([ 0 , 0 , 0 ], np . diag ( self . cell )) f . write ( \" %10.6f %10.6f xlo xhi \\n \" % xlohi ) f . write ( \" %10.6f %10.6f ylo yhi \\n \" % ylohi ) f . write ( \" %10.6f %10.6f zlo zhi \\n \" % zlohi ) f . write ( \" \\n Masses \\n\\n \" ) for i , m in enumerate ( self . atom_type_masses ): f . write ( \" %d %10.6f # %s \\n \" % ( i + 1 , m , self . label_atoms ( i ))) if len ( self . pair_coeffs ) > 0 : f . write ( ' \\n Pair Coeffs \\n\\n ' ) for i , coeffs in enumerate ( self . pair_coeffs ): f . write ( ' %d %s \\n ' % ( i + 1 , coeffs )) if len ( self . bond_type_coeffs ) > 0 : f . write ( ' \\n Bond Coeffs \\n\\n ' ) for i , coeffs in enumerate ( self . bond_type_coeffs ): f . write ( ' %d %s \\n ' % ( i + 1 , coeffs )) if len ( self . angle_type_coeffs ) > 0 : f . write ( ' \\n Angle Coeffs \\n\\n ' ) for i , coeffs in enumerate ( self . angle_type_coeffs ): f . write ( ' %d %s \\n ' % ( i + 1 , coeffs )) if len ( self . dihedral_type_coeffs ) > 0 : f . write ( ' \\n Dihedral Coeffs \\n\\n ' ) for i , coeffs in enumerate ( self . dihedral_type_coeffs ): f . write ( ' %d %s \\n ' % ( i + 1 , coeffs )) if len ( self . improper_type_coeffs ) > 0 : f . write ( ' \\n Improper Coeffs \\n\\n ' ) for i , coeffs in enumerate ( self . improper_type_coeffs ): f . write ( ' %d %s \\n ' % ( i + 1 , coeffs )) f . write ( \" \\n Atoms \\n\\n \" ) if atom_format == \"atomic\" : for i , ( x , y , z ) in enumerate ( self . positions ): f . write ( \" %d %d %10.6f %10.6f %10.6f # %s \\n \" % ( i + 1 , self . atom_types [ i ] + 1 , x , y , z , self . label_atoms ( self . atom_types [ i ]))) elif atom_format == \"full\" : for i , ( x , y , z ) in enumerate ( self . positions ): f . write ( \" %d %d %d %10.6f %10.6f %10.6f %10.6f # %s \\n \" % ( i + 1 , self . groups [ i ] + 1 , self . atom_types [ i ] + 1 , self . charges [ i ], x , y , z , self . label_atoms ( self . atom_types [ i ]))) if len ( self . bonds ) > 0 : f . write ( \" \\n Bonds \\n\\n \" ) for i , tup in enumerate ( self . bonds ): f . write ( \" %d %d %d %d # %s \\n \" % ( i + 1 , self . bond_types [ i ] + 1 , * ( np . array ( tup ) + 1 ), self . label_atoms ( tup , atom_indices = True ))) if len ( self . angles ) > 0 : f . write ( \" \\n Angles \\n\\n \" ) for i , tup in enumerate ( self . angles ): f . write ( \" %d %d %d %d %d # %s \\n \" % ( i + 1 , self . angle_types [ i ] + 1 , * ( np . array ( tup ) + 1 ), self . label_atoms ( tup , atom_indices = True ))) if len ( self . dihedrals ) > 0 : f . write ( \" \\n Dihedrals \\n\\n \" ) for i , tup in enumerate ( self . dihedrals ): f . write ( \" %d %d %d %d %d %d # %s \\n \" % ( i + 1 , self . dihedral_types [ i ] + 1 , * ( np . array ( tup ) + 1 ), self . label_atoms ( tup , atom_indices = True ))) if len ( self . impropers ) > 0 : f . write ( \" \\n Impropers \\n\\n \" ) for i , tup in enumerate ( self . impropers ): f . write ( \" %d %d %d %d %d %d # %s \\n \" % ( i + 1 , self . improper_types [ i ] + 1 , * ( np . array ( tup ) + 1 ), self . label_atoms ( tup , atom_indices = True ))) save_mol ( self , f , file_comment = '' ) Writes .mol file for structural information. Source code in mofun/atoms.py def save_mol ( self , f , file_comment = \"\" ): \"\"\"Writes .mol file for structural information.\"\"\" f . write ( \" Molecule_name: %s \\n \" % file_comment ) f . write ( \" \\n \" ) f . write ( \" Coord_Info: Listed Cartesian None \\n \" ) f . write ( \" %d \\n \" % len ( self )) for i , ( x , y , z ) in enumerate ( self . positions ): f . write ( \" %6d %10.4f %10.4f %10.4f %5s %10.8f 0 0 \\n \" % ( i + 1 , x , y , z , self . elements [ i ], self . charges [ i ])) if self . cell is not None : f . write ( \" \\n\\n\\n \" ) f . write ( \" Fundcell_Info: Listed \\n \" ) f . write ( \" %10.4f %10.4f %10.4f \\n \" % tuple ( np . diag ( self . cell ))) f . write ( \" 90.0000 90.0000 90.0000 \\n \" ) f . write ( \" 0.00000 0.00000 0.00000 \\n \" ) f . write ( \" %10.4f %10.4f %10.4f \\n \" % tuple ( np . diag ( self . cell ))) to_ase ( self ) Convert to ASE atoms object. Only supports export of the positions and elements. Source code in mofun/atoms.py def to_ase ( self ): \"\"\"Convert to ASE atoms object. Only supports export of the positions and elements. \"\"\" kwargs = dict ( positions = self . positions ) if self . cell is not None : kwargs [ 'cell' ] = self . cell kwargs [ 'pbc' ] = True return ase . Atoms ( self . elements , ** kwargs ) find_unchanged_atom_pairs ( orig_structure , final_structure , max_delta = 1e-05 ) Returns array of tuple pairs, where each pair contains the indices in the original and the final structure that match. Does not work across PBCs. Source code in mofun/atoms.py def find_unchanged_atom_pairs ( orig_structure , final_structure , max_delta = 1e-5 ): \"\"\"Returns array of tuple pairs, where each pair contains the indices in the original and the final structure that match. Does not work across PBCs.\"\"\" match_pairs = [] for i , p1 in enumerate ( orig_structure . positions ): for j , p2 in enumerate ( final_structure . positions ): if norm ( np . array ( p2 ) - p1 ) < max_delta and orig_structure . elements [ i ] == final_structure . elements [ j ]: match_pairs . append (( i , j )) break return match_pairs","title":"Atoms"},{"location":"reference/atoms/#mofun.atoms.Atoms","text":"An Atoms object is a container for all the information required to keep track of a structure and the structure's force field. See the documentation on __init__ or load to see how to create an Atoms object. An Atoms object is made up primarily of numpy arrays and a couple normal lists. Some arrays are per-atom (one entry per atom): atom_types , positions , charges , and groups . Some arrays are per-atom-type (one entry per atom type): atom_type_masses , atom_type_elements , and atom_type_labels . Some arrays are per-bond (one entry per bond): bonds , and bond_types . Some arrays are per-angle (one entry per angle): angles , and angle_types . Some arrays are per-dihedral (one entry per dihedral): dihedrals , and dihedral_types . Some arrays are per-improper (one entry per improper): impropers , and improper_types . Atoms also stores information on the coefficients needed to define each force field term: pair_coeffs , bond_type_coeffs , angle_type_coeffs , dihedral_type_coeffs , and improper_type_coeffs . The *_coeffs variables are lists of strings, where the item index corresponds to the *_type, and the string is the full LAMMPS coeffs definition string. we do not interpret any of the LAMMPS coefficient specifics, we just store it in its original form, i.e. this Angle Coeffs section: Angle Coeffs 1 cosine/periodic 72.500283 -1 1 # C_R O_1 H_ 2 cosine/periodic 277.164705 -1 3 # C_R C_R O_1 would be interpreted like this: angle_type_coeffs= [\"cosine/periodic 72.500283 -1 1 # C_R O_1 H_\", \"cosine/periodic 277.164705 -1 3 # C_R C_R O_1\"]","title":"Atoms"},{"location":"reference/atoms/#mofun.atoms.Atoms.__init__","text":"Create an Atoms object. An Atoms object can be created without any atoms using Atoms() . For creating more interesting Atoms objects, there are a few rules to keep in mind. The parameters atom_types , positions , charges , and groups are all lists that should have a size equal to the number of atoms in the system. positions is mandatory; charges , and groups are optional (both default to 0 for each atom) and there are two ways to specify atom types: 1) specify the atom_types and atom_type_elements explicitly, which is how the load_lmpdat method loads Atoms objects from a LAMMPS data file, or 2) specify per-atom elements and and have MOFUN auto-number the atom types for you, which is more convenient when specifying small molecules in code or when loading from other file formats such as CML or CIF which may store element information but not type information. When explicitly setting the types, you must pass atom_types and atom_type_elements . atom_types is a list of int type ids >= 0, one for each atom in the system. atom_type_elements is a list of element names (e.g. \"C\", \"N\", \"Zr\") per atom type . For example, if your system is propane, your atom_types list could be [0, 1, 1, 1] and your atom_type_elements list would then be [\"C\", \"H\"]. To specify per-atom elements, you must pass elements with either a list of elements, such as Atoms(elements=[\"C\", \"C\"], ...) or with a string Atoms(elements=\"CC\", ...) . If you use the elements parameter, then type ids are automatically generated. Passing atom_type_masses is optional, and masses will be inferred from the elements if missing. If you are using atom types with masses that do not correspond to periodic table elements, then you will need to specify the masses explicitly. Passing force field term information for bonds , angles , dihedrals , and impropers is optional, as well as passing force field coefficients for LAMMPS with pair_coeffs , bond_type_coeffs , angle_type_coeffs , dihedral_type_coeffs , and improper_type_coeffs . Examples: a = Atoms() # create an empty Atoms object with no atoms a = Atoms(atom_types=[0], positions=[[0,0,0]]) # create one atom of type 0 a = Atoms(elements=[\"C\"], positions=[[0,0,0]]) # create one Carbon a = Atoms(elements=[\"C\", \"C\"], positions=[[0,0,0], [1,0,0]]) # create two Carbons a = Atoms(elements=\"CC\", positions=[[0,0,0], [1,0,0]]) # create two Carbons using shorthand element notation Parameters: Name Type Description Default atom_types List[int] list of integer type ids, one per atom. [] positions List[Tuple[float, float, float]] list of tuple atom x,y,z coordinates, one per atom. [] charges List[float] list of charges, one per atom. Defaults to 0 for each atom if not passed. [] groups List[int] list of integer groups, one per atom. For LAMMPS this gets mapped to a \"molecule id\". Defaults to 0 for each atom if not passed. [] elements List[str], str either a list of elements, (e.g. [\"C\", \"H\", \"H\", \"H\"]) or an element string (e.g. \"CHHH\") [] atom_type_masses List[float] list of atom type masses, one per atom type. If masses are not passed, they will be inferred from the atom_type_elements . [] atom_type_elements List[str] list of atom type elements, one per atom type. [] atom_type_labels List[str] list of atom type labels, one per atom type. Used in LAMMPS data file line comments as type labels. [] bonds List[Tuple[int, int]] list of bond tuples where each tuple defines a pair of atoms that are bonded. Each value in the tuple is an index of an atom in the atom_* lists. [] bond_types List[int] list of bond type id ints for each bond defined in bonds . [] angles List[Tuple[int, int, int]] list of angle tuples where each tuple defines a triplet of atoms making up the angle. Each value in the tuple is an index of an atom in the atom_* lists. [] angle_types List[int] list of angle type id ints for each angle defined in angles . [] dihedrals List[Tuple[int, int, int, int]] list of dihedral tuples where each dihedral defines a quartet of atoms making up the dihedral. Each value in the tuple is an index of an atom in the atom_* lists. [] dihedral_types List[int] list of dihedral type id ints for each dihedral defined in dihedrals . [] impropers List[Tuple[int, int, int, int]] list of improper tuples where each improper defines a quartet of atoms making up the improper. Each value in the tuple is an index of an atom in the atom_* lists. [] improper_types List[int] list of improper type id ints for each improper defined in impropers . [] pair_coeffs List[str] pair coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per atom type. [] bond_type_coeffs List[str] bond coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per bond type. [] angle_type_coeffs List[str] angle coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per angle type. [] dihedral_type_coeffs List[str] dihedral coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per dihedral type. [] improper_type_coeffs List[str] improper coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per improper type. [] cell Array(3x3 3x3 array of unit cell vectors. None Returns: Type Description Atoms the atoms object. Source code in mofun/atoms.py def __init__ ( self , atom_types = [], positions = [], charges = [], groups = [], elements = [], atom_type_masses = [], atom_type_elements = [], atom_type_labels = [], bonds = [], bond_types = [], angles = [], angle_types = [], dihedrals = [], dihedral_types = [], impropers = [], improper_types = [], pair_coeffs = [], bond_type_coeffs = [], angle_type_coeffs = [], dihedral_type_coeffs = [], improper_type_coeffs = [], cell = None ): \"\"\"Create an Atoms object. An Atoms object can be created without any atoms using `Atoms()`. For creating more interesting Atoms objects, there are a few rules to keep in mind. The parameters `atom_types`, `positions`, `charges`, and `groups` are all lists that should have a size equal to the number of atoms in the system. `positions` is mandatory; `charges`, and `groups` are optional (both default to 0 for each atom) and there are two ways to specify atom types: 1) specify the atom_types and atom_type_elements explicitly, which is how the `load_lmpdat` method loads Atoms objects from a LAMMPS data file, or 2) specify per-atom elements and and have MOFUN auto-number the atom types for you, which is more convenient when specifying small molecules in code or when loading from other file formats such as CML or CIF which may store element information but not type information. When explicitly setting the types, you must pass `atom_types` and `atom_type_elements`. `atom_types` is a list of int type ids >= 0, one for each atom in the system. `atom_type_elements` is a list of element names (e.g. \"C\", \"N\", \"Zr\") per _atom type_. For example, if your system is propane, your atom_types list could be [0, 1, 1, 1] and your atom_type_elements list would then be [\"C\", \"H\"]. To specify per-atom elements, you must pass `elements` with either a list of elements, such as `Atoms(elements=[\"C\", \"C\"], ...)` or with a string `Atoms(elements=\"CC\", ...)`. If you use the `elements` parameter, then type ids are automatically generated. Passing `atom_type_masses` is optional, and masses will be inferred from the elements if missing. If you are using atom types with masses that do not correspond to periodic table elements, then you will need to specify the masses explicitly. Passing force field term information for `bonds`, `angles`, `dihedrals`, and `impropers` is optional, as well as passing force field coefficients for LAMMPS with `pair_coeffs`, `bond_type_coeffs`, `angle_type_coeffs`, `dihedral_type_coeffs`, and `improper_type_coeffs`. Examples: ``` a = Atoms() # create an empty Atoms object with no atoms a = Atoms(atom_types=[0], positions=[[0,0,0]]) # create one atom of type 0 a = Atoms(elements=[\"C\"], positions=[[0,0,0]]) # create one Carbon a = Atoms(elements=[\"C\", \"C\"], positions=[[0,0,0], [1,0,0]]) # create two Carbons a = Atoms(elements=\"CC\", positions=[[0,0,0], [1,0,0]]) # create two Carbons using shorthand element notation ``` Args: atom_types (List[int]): list of integer type ids, one per atom. positions (List[Tuple[float, float, float]]): list of tuple atom x,y,z coordinates, one per atom. charges (List[float]): list of charges, one per atom. Defaults to 0 for each atom if not passed. groups (List[int]): list of integer groups, one per atom. For LAMMPS this gets mapped to a \"molecule id\". Defaults to 0 for each atom if not passed. elements (List[str], str): either a list of elements, (e.g. [\"C\", \"H\", \"H\", \"H\"]) or an element string (e.g. \"CHHH\") atom_type_masses (List[float]): list of atom type masses, one per atom type. If masses are not passed, they will be inferred from the `atom_type_elements`. atom_type_elements (List[str]): list of atom type elements, one per atom type. atom_type_labels (List[str]): list of atom type labels, one per atom type. Used in LAMMPS data file line comments as type labels. bonds (List[Tuple[int, int]]): list of bond tuples where each tuple defines a pair of atoms that are bonded. Each value in the tuple is an index of an atom in the atom_* lists. bond_types (List[int]): list of bond type id ints for each bond defined in `bonds`. angles (List[Tuple[int, int, int]]): list of angle tuples where each tuple defines a triplet of atoms making up the angle. Each value in the tuple is an index of an atom in the atom_* lists. angle_types (List[int]): list of angle type id ints for each angle defined in `angles`. dihedrals (List[Tuple[int, int, int, int]]): list of dihedral tuples where each dihedral defines a quartet of atoms making up the dihedral. Each value in the tuple is an index of an atom in the atom_* lists. dihedral_types (List[int]): list of dihedral type id ints for each dihedral defined in `dihedrals`. impropers (List[Tuple[int, int, int, int]]): list of improper tuples where each improper defines a quartet of atoms making up the improper. Each value in the tuple is an index of an atom in the atom_* lists. improper_types (List[int]): list of improper type id ints for each improper defined in `impropers`. pair_coeffs (List[str]): pair coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per atom type. bond_type_coeffs (List[str]): bond coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per bond type. angle_type_coeffs (List[str]): angle coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per angle type. dihedral_type_coeffs (List[str]): dihedral coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per dihedral type. improper_type_coeffs (List[str]): improper coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per improper type. cell (Array(3x3)): 3x3 array of unit cell vectors. Returns: Atoms: the atoms object. \"\"\" self . atom_type_masses = np . array ( atom_type_masses , ndmin = 1 ) self . positions = np . array ( positions , dtype = float , ndmin = 1 ) if cell is not None : self . cell = np . array ( cell ) else : self . cell = None self . bonds = np . array ( bonds , dtype = int ) self . bond_types = np . array ( bond_types , dtype = int ) self . angles = np . array ( angles , dtype = int ) self . angle_types = np . array ( angle_types , dtype = int ) self . dihedrals = np . array ( dihedrals , dtype = int ) self . dihedral_types = np . array ( dihedral_types , dtype = int ) self . impropers = np . array ( impropers , dtype = int ) self . improper_types = np . array ( improper_types , dtype = int ) self . pair_coeffs = np . array ( pair_coeffs ) self . bond_type_coeffs = np . array ( bond_type_coeffs ) self . angle_type_coeffs = np . array ( angle_type_coeffs ) self . dihedral_type_coeffs = np . array ( dihedral_type_coeffs ) self . improper_type_coeffs = np . array ( improper_type_coeffs ) if len ( charges ) > 0 : self . charges = np . array ( charges , dtype = float ) else : self . charges = np . zeros ( len ( self . positions ), dtype = float ) if len ( groups ) > 0 : self . groups = np . array ( groups , dtype = int ) else : self . groups = np . zeros ( len ( self . positions ), dtype = int ) # load atom_types and atom_type_elements if len ( atom_types ) > 0 : # default case or a __getitem__ subset self . atom_types = np . array ( atom_types ) self . atom_type_elements = atom_type_elements elif len ( elements ) > 0 : # from element array, such as from ASE atoms or read CML # i.e. Propane ['C', 'H', 'H', 'H', 'C', 'H', 'H', 'C', 'H', 'H', 'H']: # or from element string, i.e. Propane \"CHHHCHHCHHH\" (shorthand): if isinstance ( elements , str ): elements = list ( Formula ( elements )) # preserve order of types self . atom_type_elements = list ( dict . fromkeys ( elements ) . keys ()) self . atom_types = np . array ([ self . atom_type_elements . index ( s ) for s in elements ]) else : # no atom_type_elements or elements passed # this should be the `Atoms()` case; if not, it will fail the asserts below self . atom_types = np . array ([], ndmin = 1 ) self . atom_type_elements = [] # automatically determine masses from elements if masses are not passed if len ( self . atom_type_masses ) == 0 and len ( self . atom_type_elements ) > 0 : self . atom_type_masses = [ ATOMIC_MASSES [ s ] for s in self . atom_type_elements ] if len ( atom_type_labels ) > 0 : self . atom_type_labels = atom_type_labels else : print ( \"WARNING: using the atom elements as the atom_type_labels since labels were not supplied.\" , file = sys . stderr ) # use default atom types equal to the element; this may not be unique! self . atom_type_labels = self . atom_type_elements self . assert_arrays_are_consistent_sizes ()","title":"__init__()"},{"location":"reference/atoms/#mofun.atoms.Atoms.extend","text":"Adds other Atoms object's arrays to its own. The default behavior is for all the types and params from other structure to be appended to this structure. Alternatively, an offsets tuple may be passed with the results of calling extend_types(). No new types will be added, but the newly added atoms, bonds, etc will refer to types by their value in the other Atoms object plus the offset. Use this when you are adding the same set of atoms multiple times, or if your other atoms already share the same type ids as this object. For the later case, the tuple (0,0,0,0) may be passed in. Parameters: Name Type Description Default other Atoms atoms to add to self required offsets an offsets tuple with the results of calling extend_types(). None structure_index_map dictionary where key is an index in other and value is an index in self, where entries only exist if the position and element of the entries are identical and can be considered to be the same atom. {} verbose bool print debugging info. False Source code in mofun/atoms.py def extend ( self , other , offsets = None , structure_index_map = {}, verbose = False ): \"\"\"Adds other Atoms object's arrays to its own. The default behavior is for all the types and params from other structure to be appended to this structure. Alternatively, an offsets tuple may be passed with the results of calling extend_types(). No new types will be added, but the newly added atoms, bonds, etc will refer to types by their value in the other Atoms object plus the offset. Use this when you are adding the same set of atoms multiple times, or if your other atoms already share the same type ids as this object. For the later case, the tuple (0,0,0,0) may be passed in. Args: other (Atoms): atoms to add to self offsets: an offsets tuple with the results of calling extend_types(). structure_index_map: dictionary where key is an index in other and value is an index in self, where entries only exist if the position and element of the entries are identical and can be considered to be the same atom. verbose (bool): print debugging info. \"\"\" atom_idx_offset = len ( self . positions ) if offsets is None : if verbose : print ( \"auto offset: extending types\" ) offsets = self . extend_types ( other ) # update atom types for atoms that are already part of self Atoms object for other_index , self_index in structure_index_map . items (): self . atom_types [ self_index ] = other . atom_types [ other_index ] + offsets [ 0 ] # add atoms that are not part of self Atoms object atoms_to_add = [ i for i in range ( len ( other )) if i not in structure_index_map . keys ()] self . positions = np . append ( self . positions , other . positions [ atoms_to_add ], axis = 0 ) self . atom_types = np . append ( self . atom_types , other . atom_types [ atoms_to_add ] + offsets [ 0 ]) self . charges = np . append ( self . charges , other . charges [ atoms_to_add ]) self . groups = np . append ( self . groups , other . groups [ atoms_to_add ]) # update structure index map structure_index_map2 = { a : i + atom_idx_offset for i , a in enumerate ( atoms_to_add )} structure_index_map2 . update ( structure_index_map ) convert2structureindex = np . vectorize ( structure_index_map2 . get ) def find_existing_topo ( topo , new_topo ): \"\"\" find existing topo tuples between the same atoms as a new topo set. Used to allow an override of an existing force field term by finding old terms between the same atoms to delete\"\"\" if len ( topo ) == 0 : return [] return list ( np . nonzero ( cdist ( topo , new_topo , 'cityblock' ) == 0 )[ 0 ]) if len ( other . bonds ) > 0 : new_bonds = convert2structureindex ( other . bonds ) existing_bond_indices = find_existing_topo ( self . bonds , new_bonds ) self . bonds = np . append ( self . bonds , new_bonds ) . reshape (( - 1 , 2 )) self . bond_types = np . append ( self . bond_types , other . bond_types + offsets [ 1 ]) self . bonds = np . delete ( self . bonds , existing_bond_indices , axis = 0 ) self . bond_types = np . delete ( self . bond_types , existing_bond_indices ) if len ( other . angles ) > 0 : new_angles = convert2structureindex ( other . angles ) existing_angle_indices = find_existing_topo ( self . angles , new_angles ) self . angles = np . append ( self . angles , new_angles ) . reshape (( - 1 , 3 )) self . angle_types = np . append ( self . angle_types , other . angle_types + offsets [ 2 ]) self . angles = np . delete ( self . angles , existing_angle_indices , axis = 0 ) self . angle_types = np . delete ( self . angle_types , existing_angle_indices ) if len ( other . dihedrals ) > 0 : new_dihedrals = convert2structureindex ( other . dihedrals ) existing_dihedral_indices = find_existing_topo ( self . dihedrals , new_dihedrals ) self . dihedrals = np . append ( self . dihedrals , new_dihedrals ) . reshape (( - 1 , 4 )) self . dihedral_types = np . append ( self . dihedral_types , other . dihedral_types + offsets [ 3 ]) self . dihedrals = np . delete ( self . dihedrals , existing_dihedral_indices , axis = 0 ) self . dihedral_types = np . delete ( self . dihedral_types , existing_dihedral_indices ) if len ( other . impropers ) > 0 : new_impropers = convert2structureindex ( other . impropers ) existing_improper_indices = find_existing_topo ( self . impropers , new_impropers ) self . impropers = np . append ( self . impropers , new_impropers ) . reshape (( - 1 , 4 )) self . improper_types = np . append ( self . improper_types , other . improper_types + offsets [ 4 ]) self . impropers = np . delete ( self . impropers , existing_improper_indices , axis = 0 ) self . improper_types = np . delete ( self . improper_types , existing_improper_indices ) self . assert_arrays_are_consistent_sizes ()","title":"extend()"},{"location":"reference/atoms/#mofun.atoms.Atoms.from_ase_atoms","text":"Create an Atoms object from an ASE Atoms object. Only supports importing the atom positions, elements, and the unit cell. Parameters: Name Type Description Default atoms ASE Atoms object atoms to load from required Returns: Type Description Atoms atoms loaded from an ASE Atoms object. Source code in mofun/atoms.py @classmethod def from_ase_atoms ( cls , atoms ): \"\"\"Create an Atoms object from an ASE Atoms object. Only supports importing the atom positions, elements, and the unit cell. Args: atoms (ASE Atoms object): atoms to load from Returns: Atoms: atoms loaded from an ASE Atoms object. \"\"\" return cls ( elements = atoms . symbols , positions = atoms . positions , cell = atoms . cell )","title":"from_ase_atoms()"},{"location":"reference/atoms/#mofun.atoms.Atoms.load","text":"Creates an Atoms object from either a path or a file object and filetype. Can load any of the supported types: lammps data file: \"lmpdat\" cif cml Parameters: Name Type Description Default f Str or Path or File either a path to a file or an open File to load from required filetype Str filetype ('lmpdat', 'cif', or 'cml') of passed f File object, or explicit filetype to override default filetype implied from file extension. None kwargs keyword args passed on to individual load functions. {} Source code in mofun/atoms.py @classmethod def load ( cls , f , filetype = None , ** kwargs ): \"\"\"Creates an Atoms object from either a path or a file object and filetype. Can load any of the supported types: - lammps data file: \"lmpdat\" - cif - cml Args: f (Str or Path or File): either a path to a file or an open File to load from filetype (Str): filetype ('lmpdat', 'cif', or 'cml') of passed f File object, or explicit filetype to override default filetype implied from file extension. kwargs: keyword args passed on to individual load functions. \"\"\" fd = None path = None if isinstance ( f , io . TextIOBase ): fd = f if filetype is None : raise Exception ( \"If a File object is passed, a filetype must be passed with it\" ) else : # other cases are treated as either Pathlib path or strings path = f if filetype is None : _ , filetype = os . path . splitext ( path ) filetype = filetype [ 1 :] if filetype == \"lmpdat\" : with use_or_open ( fd , path ) as fh : atoms = cls . load_lmpdat ( fh , ** kwargs ) return atoms elif filetype == \"cml\" : return cls . load_cml ( fd or path , ** kwargs ) elif filetype == \"cif\" : with use_or_open ( fd , path ) as fh : return cls . load_cif ( fh , ** kwargs ) else : raise Exception ( \"Unsupported filetype\" )","title":"load()"},{"location":"reference/atoms/#mofun.atoms.Atoms.load_cif","text":"Loads a CIF file, including bonding information. Parameters: Name Type Description Default f File File-like object to read from. required Returns: Type Description Atoms loaded Atoms object Source code in mofun/atoms.py @classmethod def load_cif ( cls , f ): \"\"\"Loads a CIF file, including bonding information. Args: f (File): File-like object to read from. Returns: Atoms: loaded Atoms object \"\"\" def has_all_tags ( block , tags ): return np . array ([ block . has_key ( tag ) for tag in tags ]) . all () # PyCifRw supports file descriptors and path strings, but doesn't not support PathLib paths. if isinstance ( f , pathlib . PurePath ): f = str ( f ) cf = read_cif ( f ) block = cf [ cf . get_roots ()[ 0 ][ 0 ]] cart_coord_tags = [ \"_atom_site_Cartn_x\" , \"_atom_site_Cartn_y\" , \"_atom_site_Cartn_z\" , \"_atom_site_label\" ] fract_coord_tags = [ \"_atom_site_fract_x\" , \"_atom_site_fract_y\" , \"_atom_site_fract_z\" , \"_atom_site_label\" ] use_fract_coords = False if has_all_tags ( block , cart_coord_tags ): coords = [ block [ lbl ] for lbl in cart_coord_tags ] elif has_all_tags ( block , fract_coord_tags ): use_fract_coords = True coords = [ block [ lbl ] for lbl in fract_coord_tags ] else : raise ( \"no fractional or cartesian coords in CIF file\" ) x = [ float ( c ) for c in coords [ 0 ]] y = [ float ( c ) for c in coords [ 1 ]] z = [ float ( c ) for c in coords [ 2 ]] atom_name = coords [ 3 ] positions = np . array ([ x , y , z ], dtype = float ) . T atom_types = block [ '_atom_site_type_symbol' ] charges = [] if block . has_key ( '_atom_site_charge' ): charges = block [ '_atom_site_charge' ] bonds = [] bond_tags = [ \"_geom_bond_atom_site_label_1\" , \"_geom_bond_atom_site_label_2\" ] if has_all_tags ( block , bond_tags ): cifbonds = zip ( * [ block [ lbl ] for lbl in bond_tags ]) bonds = [( atom_name . index ( a ), atom_name . index ( b )) for ( a , b ) in cifbonds ] print ( \"WARNING: cif read doesn't handle bond types at present; bonding info is discarded. Use LAMMPS data file format if you need bonds\" , file = sys . stderr ) bonds = [] cell = None cell_tags = [ '_cell_length_a' , '_cell_length_b' , '_cell_length_c' , '_cell_angle_alpha' , '_cell_angle_beta' , '_cell_angle_gamma' ] if has_all_tags ( block , cell_tags ): a , b , c , alpha , beta , gamma = [ float ( block [ tag ]) for tag in cell_tags ] # TODO: Fix for triclinic if alpha != 90. or beta != 90 or gamma != 90. : raise Exception ( \"No support for non orthorhombic UCs at the moment!\" ) cell = np . identity ( 3 ) * ( a , b , c ) if use_fract_coords : positions *= ( a , b , c ) return cls ( elements = atom_types , positions = positions , cell = cell , charges = charges )","title":"load_cif()"},{"location":"reference/atoms/#mofun.atoms.Atoms.load_cml","text":"Loads a CML file, including bonding information. Parameters: Name Type Description Default f Path or File Path or File-like object to read from. required Returns: Type Description Atoms loaded Atoms object Source code in mofun/atoms.py @classmethod def load_cml ( cls , f , verbose = False ): \"\"\"Loads a CML file, including bonding information. Args: f (Path or File): Path or File-like object to read from. Returns: Atoms: loaded Atoms object \"\"\" tree = ET . parse ( f ) root = tree . getroot () atom_dicts = [ a . attrib for a in root . findall ( './/atom' )] atom_tuples = [( a [ 'id' ], a [ 'elementType' ], float ( a [ 'x3' ]), float ( a [ 'y3' ]), float ( a [ 'z3' ])) for a in atom_dicts ] ids , elements , x , y , z = zip ( * atom_tuples ) id_to_idx = { id : i for i , id in enumerate ( ids )} positions = np . array ([ x , y , z ]) . T bond_dicts = [ a . attrib for a in root . findall ( './/bond' )] bond_tuples = [( a [ 'atomRefs2' ] . split (), float ( a [ 'order' ])) for a in bond_dicts ] bonds_by_ids , bond_orders = zip ( * bond_tuples ) bonds = [( id_to_idx [ b1 ], id_to_idx [ b2 ]) for ( b1 , b2 ) in bonds_by_ids ] bond_types = [ 0 for b in bonds ] if verbose : print ( \"Found %d atoms: %s \" % ( len ( elements ), elements )) print ( \"Found %d atom positions: %s \" % ( len ( positions ), positions )) print ( \"Found %d bonds: %s \" % ( len ( bonds ), bonds )) print ( \"Found %d bond_types: %s \" % ( len ( bond_types ), bond_types )) return cls ( elements = elements , positions = positions , bonds = bonds , bond_types = bond_types )","title":"load_cml()"},{"location":"reference/atoms/#mofun.atoms.Atoms.load_lmpdat","text":"Load Atoms object from lammps data file (.lmpdat) format. LAMMPS data files store only atom ids and masses, but do not store two other things we need: elements and atom type labels. These are the rules for inferring atom type labels and elements. In priority order, for elements, we: guess the elements using the masses by seeing if there is a periodic table element within 0.1 g/mol of the mass. If any atom types doe not match to an existing periodic table element, this method fails. use the atom ids as the elements (and print a warning). In priority order, for atom type labels, we: use the comments after each line in the Masses section as the atom type. If any line is missing a comment, this method fails. use the elements, if we have them. use the atom ids (and print a warning). Parameters: Name Type Description Default f File File-like object to read from. required atom_format str atom format of lammps data file. Currently supported atom formats are 'full' and 'atomic'. 'full' guess_atol float absolute tolerance a read mass can differ from a periodic table mass and still be considered that element. Default: 0.1. 0.1 Returns: Type Description Atoms loaded Atoms object Source code in mofun/atoms.py @classmethod def load_lmpdat ( cls , f , atom_format = \"full\" , guess_atol = 0.1 ): \"\"\"Load Atoms object from lammps data file (.lmpdat) format. LAMMPS data files store only atom ids and masses, but do not store two other things we need: elements and atom type labels. These are the rules for inferring atom type labels and elements. In priority order, for elements, we: 1. guess the elements using the masses by seeing if there is a periodic table element within 0.1 g/mol of the mass. If any atom types doe not match to an existing periodic table element, this method fails. 2. use the atom ids as the elements (and print a warning). In priority order, for atom type labels, we: 1. use the comments after each line in the Masses section as the atom type. If any line is missing a comment, this method fails. 2. use the elements, if we have them. 3. use the atom ids (and print a warning). Args: f (File): File-like object to read from. atom_format (str): atom format of lammps data file. Currently supported atom formats are 'full' and 'atomic'. guess_atol (float): absolute tolerance a read mass can differ from a periodic table mass and still be considered that element. Default: 0.1. Returns: Atoms: loaded Atoms object \"\"\" def get_types_tups ( arr ): types = tups = [] if len ( arr ) > 0 : types = arr [:, 1 ] - 1 tups = arr [:, 2 :] - 1 return types , tups masses = [] atoms = [] bonds = [] angles = [] dihedrals = [] impropers = [] pair_coeffs = [] bond_coeffs = [] angle_coeffs = [] dihedral_coeffs = [] improper_coeffs = [] atom_type_labels = [] atom_type_elements = [] cellx = celly = cellz = 0.0 sections_handled = [ \"Pair Coeffs\" , \"Bond Coeffs\" , \"Angle Coeffs\" , \"Dihedral Coeffs\" , \"Improper Coeffs\" , \"Atoms\" , \"Bonds\" , \"Angles\" , \"Dihedrals\" , \"Impropers\" , \"Masses\" ] current_section = None start_section = False for unprocessed_line in f : # handle comments comment_string = \"\" comment = None if \"#\" in unprocessed_line : line , comment = unprocessed_line . split ( '#' ) comment = comment . strip () comment_string = \" # \" + comment else : line = unprocessed_line . split ( '#' )[ 0 ] line = line . strip () if line in sections_handled : current_section = line start_section = True continue elif line == \"\" : if not start_section : # end of section or blank current_section = None start_section = False continue tup = line . split () if current_section == \"Masses\" : masses . append ( tup [ 1 ]) atom_type_labels . append ( comment ) elif current_section == \"Pair Coeffs\" : pair_coeffs . append ( \" %s%s \" % ( \" \" . join ( tup [ 1 :]), comment_string )) elif current_section == \"Bond Coeffs\" : bond_coeffs . append ( \" %s%s \" % ( \" \" . join ( tup [ 1 :]), comment_string )) elif current_section == \"Angle Coeffs\" : angle_coeffs . append ( \" %s%s \" % ( \" \" . join ( tup [ 1 :]), comment_string )) elif current_section == \"Dihedral Coeffs\" : dihedral_coeffs . append ( \" %s%s \" % ( \" \" . join ( tup [ 1 :]), comment_string )) elif current_section == \"Improper Coeffs\" : improper_coeffs . append ( \" %s%s \" % ( \" \" . join ( tup [ 1 :]), comment_string )) elif current_section == \"Atoms\" : atoms . append ( tup ) elif current_section == \"Bonds\" : bonds . append ( tup ) elif current_section == \"Angles\" : angles . append ( tup ) elif current_section == \"Dihedrals\" : dihedrals . append ( tup ) elif current_section == \"Impropers\" : impropers . append ( tup ) elif current_section is None : if \"xlo xhi\" in line : cellx = float ( tup [ 1 ]) - float ( tup [ 0 ]) elif \"ylo yhi\" in line : celly = float ( tup [ 1 ]) - float ( tup [ 0 ]) elif \"zlo zhi\" in line : cellz = float ( tup [ 1 ]) - float ( tup [ 0 ]) cell = None if cellx > 0. and celly > 0. and cellz > 0. : cell = np . identity ( 3 ) * ( cellx , celly , cellz ) atom_type_masses = np . array ( masses , dtype = float ) atoms = np . array ( atoms , dtype = float ) bonds = np . array ( bonds , dtype = int ) angles = np . array ( angles , dtype = int ) dihedrals = np . array ( dihedrals , dtype = int ) impropers = np . array ( impropers , dtype = int ) # note: bond indices in lmpdat file are 1-indexed and we are 0-indexed which is why # the bond pairs get a -1 if atom_format == \"atomic\" : atom_types = np . array ( atoms [:, 1 ] - 1 , dtype = int ) groups = np . zeros ( len ( atom_types )) charges = np . zeros ( len ( atom_types )) atom_tups = atoms [:, 2 : 5 ] elif atom_format == \"full\" : groups = np . array ( atoms [:, 1 ] - 1 , dtype = int ) atom_types = np . array ( atoms [:, 2 ] - 1 , dtype = int ) charges = np . array ( atoms [:, 3 ], dtype = float ) atom_tups = atoms [:, 4 : 7 ] # guess the atom elements; if this fails, use the atoms ids as the elements try : atom_type_elements = guess_elements_from_masses ( atom_type_masses , max_delta = guess_atol ) except Exception : print ( \"WARNING: using type ids for elements since some masses do not correspond to periodic table elements within the set tolerance.\" , file = sys . stderr ) atom_type_elements = [ str ( i + 1 ) for i in range ( len ( masses ))] # infer the atom type labels if ( atom_type_labels . count ( None ) == 0 ): # then loading atom types from the labels worked pass else : print ( \"WARNING: using elements for atom type labels since there is not an atom type label comment for every atom type in the Masses section.\" , file = sys . stderr ) atom_type_labels = atom_type_elements . copy () bond_types , bond_tups = get_types_tups ( bonds ) angle_types , angle_tups = get_types_tups ( angles ) dihedral_types , dihedral_tups = get_types_tups ( dihedrals ) improper_types , improper_tups = get_types_tups ( impropers ) return cls ( atom_types = atom_types , positions = atom_tups , charges = charges , atom_type_masses = atom_type_masses , atom_type_elements = atom_type_elements , bond_types = bond_types , bonds = bond_tups , angle_types = angle_types , angles = angle_tups , dihedral_types = dihedral_types , dihedrals = dihedral_tups , improper_types = improper_types , impropers = improper_tups , pair_coeffs = pair_coeffs , bond_type_coeffs = bond_coeffs , angle_type_coeffs = angle_coeffs , dihedral_type_coeffs = dihedral_coeffs , improper_type_coeffs = improper_coeffs , atom_type_labels = atom_type_labels , groups = groups , cell = cell )","title":"load_lmpdat()"},{"location":"reference/atoms/#mofun.atoms.Atoms.replicate","text":"Replicate atoms object across xyz dimensions Warnings: * does not magically handle any bonds that may cross periodic boundary conditions! Parameters: Name Type Description Default repldims Tuple(int, int, int number of times to replicate in each dimension (1, 1, 1) Returns: Type Description Atoms replicated atoms. Source code in mofun/atoms.py def replicate ( self , repldims = ( 1 , 1 , 1 )): \"\"\"Replicate atoms object across xyz dimensions Warnings: * does not magically handle any bonds that may cross periodic boundary conditions! Args: repldims (Tuple(int, int, int)): number of times to replicate in each dimension Returns: Atoms: replicated atoms. \"\"\" if self . cell is None : raise Exception ( \"Can't replicate if no unit cell has been defined\" ) repl_atoms = self . copy () ucmults = np . array ( np . meshgrid ( * [ range ( r ) for r in repldims ])) . T . reshape ( - 1 , 3 ) ucmults = ucmults [ np . any ( ucmults != 0 , axis = 1 )] # remove [0,0,0] since in copy for ucmult in ucmults : transatoms = self . copy () transatoms . translate ( np . matmul ( transatoms . cell . T , ucmult )) repl_atoms . extend ( transatoms , offsets = ( 0 , 0 , 0 , 0 )) repl_atoms . cell = self . cell * repldims return repl_atoms","title":"replicate()"},{"location":"reference/atoms/#mofun.atoms.Atoms.save","text":"Saves an Atoms object to either a path or a file object and filetype. Can save any of the supported types: lammps data file: \"lmpdat\" mol Parameters: Name Type Description Default f Str or Path or File either a path to a file or an open File to save to required filetype Str filetype ('lmpdat', 'cif', or 'cml') of passed f File object, or explicit filetype to override default filetype implied from file extension. None kwargs keyword args passed on to individual save functions. {} Source code in mofun/atoms.py def save ( self , f , filetype = None , ** kwargs ): \"\"\"Saves an Atoms object to either a path or a file object and filetype. Can save any of the supported types: - lammps data file: \"lmpdat\" - mol Args: f (Str or Path or File): either a path to a file or an open File to save to filetype (Str): filetype ('lmpdat', 'cif', or 'cml') of passed f File object, or explicit filetype to override default filetype implied from file extension. kwargs: keyword args passed on to individual save functions. \"\"\" fd = None path = None if isinstance ( f , io . TextIOBase ): fd = f if filetype is None : raise Exception ( \"If a File object is passed, a filetype must be passed with it\" ) else : # other cases are treated as either Pathlib path or strings path = f if filetype is None : _ , filetype = os . path . splitext ( path ) filetype = filetype [ 1 :] if filetype == \"lmpdat\" : with use_or_open ( fd , path , mode = 'w' ) as fh : atoms = self . save_lmpdat ( fh , ** kwargs ) return atoms elif filetype == \"mol\" : with use_or_open ( fd , path , mode = 'w' ) as fh : return self . save_mol ( fh , ** kwargs ) else : raise Exception ( \"Unsupported filetype\" )","title":"save()"},{"location":"reference/atoms/#mofun.atoms.Atoms.save_lmpdat","text":"Saves a lmpdat file Parameters: Name Type Description Default f File an open file to write to required atom_format str LAMMPS atom format. Supports only 'atomic' and 'full'. 'full' file_comment str written in first line of output file. '' Source code in mofun/atoms.py def save_lmpdat ( self , f , atom_format = \"full\" , file_comment = \"\" ): \"\"\"Saves a lmpdat file Args: f (File): an open file to write to atom_format (str): LAMMPS atom format. Supports only 'atomic' and 'full'. file_comment (str): written in first line of output file. \"\"\" f . write ( \" %s (written by mofun) \\n\\n \" % file_comment ) f . write ( ' %d atoms \\n ' % len ( self . atom_types )) f . write ( ' %d bonds \\n ' % len ( self . bond_types )) f . write ( ' %d angles \\n ' % len ( self . angle_types )) f . write ( ' %d dihedrals \\n ' % len ( self . dihedral_types )) f . write ( ' %d impropers \\n ' % len ( self . improper_types )) f . write ( \" \\n \" ) if self . num_atom_types > 0 : f . write ( ' %d atom types \\n ' % self . num_atom_types ) if self . num_bond_types > 0 : f . write ( ' %d bond types \\n ' % self . num_bond_types ) if self . num_angle_types > 0 : f . write ( ' %d angle types \\n ' % self . num_angle_types ) if self . num_dihedral_types > 0 : f . write ( ' %d dihedral types \\n ' % self . num_dihedral_types ) if self . num_improper_types > 0 : f . write ( ' %d improper types \\n ' % self . num_improper_types ) # TODO: support triclinic if self . cell is not None and self . cell . shape == ( 3 , 3 ): xlohi , ylohi , zlohi = zip ([ 0 , 0 , 0 ], np . diag ( self . cell )) f . write ( \" %10.6f %10.6f xlo xhi \\n \" % xlohi ) f . write ( \" %10.6f %10.6f ylo yhi \\n \" % ylohi ) f . write ( \" %10.6f %10.6f zlo zhi \\n \" % zlohi ) f . write ( \" \\n Masses \\n\\n \" ) for i , m in enumerate ( self . atom_type_masses ): f . write ( \" %d %10.6f # %s \\n \" % ( i + 1 , m , self . label_atoms ( i ))) if len ( self . pair_coeffs ) > 0 : f . write ( ' \\n Pair Coeffs \\n\\n ' ) for i , coeffs in enumerate ( self . pair_coeffs ): f . write ( ' %d %s \\n ' % ( i + 1 , coeffs )) if len ( self . bond_type_coeffs ) > 0 : f . write ( ' \\n Bond Coeffs \\n\\n ' ) for i , coeffs in enumerate ( self . bond_type_coeffs ): f . write ( ' %d %s \\n ' % ( i + 1 , coeffs )) if len ( self . angle_type_coeffs ) > 0 : f . write ( ' \\n Angle Coeffs \\n\\n ' ) for i , coeffs in enumerate ( self . angle_type_coeffs ): f . write ( ' %d %s \\n ' % ( i + 1 , coeffs )) if len ( self . dihedral_type_coeffs ) > 0 : f . write ( ' \\n Dihedral Coeffs \\n\\n ' ) for i , coeffs in enumerate ( self . dihedral_type_coeffs ): f . write ( ' %d %s \\n ' % ( i + 1 , coeffs )) if len ( self . improper_type_coeffs ) > 0 : f . write ( ' \\n Improper Coeffs \\n\\n ' ) for i , coeffs in enumerate ( self . improper_type_coeffs ): f . write ( ' %d %s \\n ' % ( i + 1 , coeffs )) f . write ( \" \\n Atoms \\n\\n \" ) if atom_format == \"atomic\" : for i , ( x , y , z ) in enumerate ( self . positions ): f . write ( \" %d %d %10.6f %10.6f %10.6f # %s \\n \" % ( i + 1 , self . atom_types [ i ] + 1 , x , y , z , self . label_atoms ( self . atom_types [ i ]))) elif atom_format == \"full\" : for i , ( x , y , z ) in enumerate ( self . positions ): f . write ( \" %d %d %d %10.6f %10.6f %10.6f %10.6f # %s \\n \" % ( i + 1 , self . groups [ i ] + 1 , self . atom_types [ i ] + 1 , self . charges [ i ], x , y , z , self . label_atoms ( self . atom_types [ i ]))) if len ( self . bonds ) > 0 : f . write ( \" \\n Bonds \\n\\n \" ) for i , tup in enumerate ( self . bonds ): f . write ( \" %d %d %d %d # %s \\n \" % ( i + 1 , self . bond_types [ i ] + 1 , * ( np . array ( tup ) + 1 ), self . label_atoms ( tup , atom_indices = True ))) if len ( self . angles ) > 0 : f . write ( \" \\n Angles \\n\\n \" ) for i , tup in enumerate ( self . angles ): f . write ( \" %d %d %d %d %d # %s \\n \" % ( i + 1 , self . angle_types [ i ] + 1 , * ( np . array ( tup ) + 1 ), self . label_atoms ( tup , atom_indices = True ))) if len ( self . dihedrals ) > 0 : f . write ( \" \\n Dihedrals \\n\\n \" ) for i , tup in enumerate ( self . dihedrals ): f . write ( \" %d %d %d %d %d %d # %s \\n \" % ( i + 1 , self . dihedral_types [ i ] + 1 , * ( np . array ( tup ) + 1 ), self . label_atoms ( tup , atom_indices = True ))) if len ( self . impropers ) > 0 : f . write ( \" \\n Impropers \\n\\n \" ) for i , tup in enumerate ( self . impropers ): f . write ( \" %d %d %d %d %d %d # %s \\n \" % ( i + 1 , self . improper_types [ i ] + 1 , * ( np . array ( tup ) + 1 ), self . label_atoms ( tup , atom_indices = True )))","title":"save_lmpdat()"},{"location":"reference/atoms/#mofun.atoms.Atoms.save_mol","text":"Writes .mol file for structural information. Source code in mofun/atoms.py def save_mol ( self , f , file_comment = \"\" ): \"\"\"Writes .mol file for structural information.\"\"\" f . write ( \" Molecule_name: %s \\n \" % file_comment ) f . write ( \" \\n \" ) f . write ( \" Coord_Info: Listed Cartesian None \\n \" ) f . write ( \" %d \\n \" % len ( self )) for i , ( x , y , z ) in enumerate ( self . positions ): f . write ( \" %6d %10.4f %10.4f %10.4f %5s %10.8f 0 0 \\n \" % ( i + 1 , x , y , z , self . elements [ i ], self . charges [ i ])) if self . cell is not None : f . write ( \" \\n\\n\\n \" ) f . write ( \" Fundcell_Info: Listed \\n \" ) f . write ( \" %10.4f %10.4f %10.4f \\n \" % tuple ( np . diag ( self . cell ))) f . write ( \" 90.0000 90.0000 90.0000 \\n \" ) f . write ( \" 0.00000 0.00000 0.00000 \\n \" ) f . write ( \" %10.4f %10.4f %10.4f \\n \" % tuple ( np . diag ( self . cell )))","title":"save_mol()"},{"location":"reference/atoms/#mofun.atoms.Atoms.to_ase","text":"Convert to ASE atoms object. Only supports export of the positions and elements. Source code in mofun/atoms.py def to_ase ( self ): \"\"\"Convert to ASE atoms object. Only supports export of the positions and elements. \"\"\" kwargs = dict ( positions = self . positions ) if self . cell is not None : kwargs [ 'cell' ] = self . cell kwargs [ 'pbc' ] = True return ase . Atoms ( self . elements , ** kwargs )","title":"to_ase()"},{"location":"reference/atoms/#mofun.atoms.find_unchanged_atom_pairs","text":"Returns array of tuple pairs, where each pair contains the indices in the original and the final structure that match. Does not work across PBCs. Source code in mofun/atoms.py def find_unchanged_atom_pairs ( orig_structure , final_structure , max_delta = 1e-5 ): \"\"\"Returns array of tuple pairs, where each pair contains the indices in the original and the final structure that match. Does not work across PBCs.\"\"\" match_pairs = [] for i , p1 in enumerate ( orig_structure . positions ): for j , p2 in enumerate ( final_structure . positions ): if norm ( np . array ( p2 ) - p1 ) < max_delta and orig_structure . elements [ i ] == final_structure . elements [ j ]: match_pairs . append (( i , j )) break return match_pairs","title":"find_unchanged_atom_pairs()"},{"location":"reference/mofun/","text":"find_pattern_in_structure ( structure , pattern , axisp1_idx = 0 , axisp2_idx =- 1 , opoint_idx = None , return_positions_and_quats = False , atol = 0.05 , verbose = False ) Looks for instances of pattern in structure , where a match in the structure has the same number of atoms, the same elements and the same relative coordinates as in pattern . Returns a list of tuples, one tuple per match found in structure where each tuple has the size len(pattern) and contains the indices in the structure that matched the pattern. If return_positions_and_quats=True then two additional lists are returned containing positions for each matched index for each match, and the quaternions required to rotate the search pattern to the match pattern. Parameters: Name Type Description Default structure Atoms an Atoms object to search in. required pattern Atoms an Atoms object to search for. required axisp1_idx float index in search_pattern of first point defining the directional axis of the search_pattern. May help with performance for large problems. 0 axisp2_idx float index in search_pattern of second point defining the directional axis of the search_pattern. May help with performance for large problems. -1 opoint_idx float index in search_pattern of the orientation point that we will use to align the search pattern (the search pattern will be rotated so that the orientation point in the search pattern will have the same coordinates as the same point in the match pattern). None return_positions_and_quats bool additionally returns the positions for each index and the quaternions that rotation the search pattern to the match pattern. False atol float the absolute tolerance (how close an atom must be in the structure to the position in pattern to be considered a match). 0.05 verbose bool print debugging info. False Returns: Type Description List [tuple(len(pattern))], {List [tuple(len(pattern))], List [scipy.spatial.transform.Rotation]} returns a list of tuples of size len(pattern) containing the indices in the structure that matched the pattern, one tuple per each match, and optionally (if return_positions_and_quats is True) a corresponding list of tuples with positions instead of indices, and a list of quaternions (scipy.spatial.transform.Rotation), one per each match. Source code in mofun/mofun.py @suppress_warnings def find_pattern_in_structure ( structure , pattern , axisp1_idx = 0 , axisp2_idx =- 1 , opoint_idx = None , return_positions_and_quats = False , atol = 5e-2 , verbose = False ): \"\"\"Looks for instances of `pattern` in `structure`, where a match in the structure has the same number of atoms, the same elements and the same relative coordinates as in `pattern`. Returns a list of tuples, one tuple per match found in `structure` where each tuple has the size `len(pattern)` and contains the indices in the structure that matched the pattern. If `return_positions_and_quats=True` then two additional lists are returned containing positions for each matched index for each match, and the quaternions required to rotate the search pattern to the match pattern. Args: structure (Atoms): an Atoms object to search in. pattern (Atoms): an Atoms object to search for. axisp1_idx (float): index in search_pattern of first point defining the directional axis of the search_pattern. May help with performance for large problems. axisp2_idx (float): index in search_pattern of second point defining the directional axis of the search_pattern. May help with performance for large problems. opoint_idx (float): index in search_pattern of the orientation point that we will use to align the search pattern (the search pattern will be rotated so that the orientation point in the search pattern will have the same coordinates as the same point in the match pattern). return_positions_and_quats (bool): additionally returns the positions for each index and the quaternions that rotation the search pattern to the match pattern. atol (float): the absolute tolerance (how close an atom must be in the structure to the position in pattern to be considered a match). verbose (bool): print debugging info. Returns: List [tuple(len(pattern))], {List [tuple(len(pattern))], List [scipy.spatial.transform.Rotation]} : returns a list of tuples of size `len(pattern)` containing the indices in the structure that matched the pattern, one tuple per each match, and optionally (if return_positions_and_quats is True) a corresponding list of tuples with positions instead of indices, and a list of quaternions (scipy.spatial.transform.Rotation), one per each match. \"\"\" if verbose : print ( \"calculating point distances...\" ) p_ss = distance . cdist ( pattern . positions , pattern . positions , \"sqeuclidean\" ) pattern_length = p_ss . max () ** 0.5 + 2 * atol s_types_view , index_mapper , s_pos_view , s_positions = get_types_ss_map_limited_near_uc ( structure , pattern_length ) atoms_by_type = atoms_by_type_dict ( s_types_view ) # created sorted coords array for creating search subsets p = np . array ( sorted ([( * r , i ) for i , r in enumerate ( s_pos_view )])) # Search instances of first atom in a search pattern # 0,0,0 uc atoms are always indexed first from 0 to # atoms in structure. starting_atoms = [ idx for idx in atoms_of_type ( s_types_view [ 0 : len ( structure )], pattern . elements [ 0 ])] if verbose : print ( \"round %d ( %d ) [ %s ]: \" % ( 0 , len ( starting_atoms ), pattern . elements [ 0 ]), starting_atoms ) def get_nearby_atoms ( p , s_pos_view , pattern_length , a ): p1 = p [( p [:, 0 ] <= s_pos_view [ a ][ 0 ] + pattern_length ) & ( p [:, 0 ] >= s_pos_view [ a ][ 0 ] - pattern_length )] p2 = p1 [( p1 [:, 1 ] <= s_pos_view [ a ][ 1 ] + pattern_length ) & ( p1 [:, 1 ] >= s_pos_view [ a ][ 1 ] - pattern_length )] return ( p2 [( p2 [:, 2 ] <= s_pos_view [ a ][ 2 ] + pattern_length ) & ( p2 [:, 2 ] >= s_pos_view [ a ][ 2 ] - pattern_length )]) pattern_elements = pattern . elements all_match_index_tuples = [] for a_idx , a in enumerate ( starting_atoms ): match_index_tuples = [[ a ]] nearby = get_nearby_atoms ( p , s_pos_view , pattern_length , a ) nearby_atom_indices = nearby [:, 3 ] . astype ( np . int32 ) nearby_positions = nearby [:, 0 : 3 ] idx2ssidx = { atom_idx : i for i , atom_idx in enumerate ( nearby_atom_indices )} s_ss = distance . cdist ( nearby_positions , nearby_positions , \"sqeuclidean\" ) # start for loop at one since we've searched for starting atoms (index == 0) above for i in range ( 1 , len ( pattern )): if len ( match_index_tuples ) == 0 : break last_match_index_tuples = match_index_tuples match_index_tuples = [] for match in last_match_index_tuples : for ss_idx , atom_idx in enumerate ( nearby_atom_indices ): if s_types_view [ atom_idx ] == pattern_elements [ i ]: found_match = True # check all distances to this new proposed atom for j in range ( 0 , i ): if not math . isclose ( p_ss [ i , j ] ** 0.5 , s_ss [ idx2ssidx [ match [ j ]], ss_idx ] ** 0.5 , abs_tol = atol ): found_match = False break # anything that matches the distance to all prior pattern atoms is a good match so far if found_match : match_index_tuples . append ( match + [ atom_idx ]) if verbose : print ( \"round %d ( %d ) [ %s ]: \" % ( i , len ( match_index_tuples ), pattern . elements [ i ]), match_index_tuples ) if verbose : print ( \"starting atom %d : found %d matches: %s \" % ( a_idx , len ( match_index_tuples ), match_index_tuples )) all_match_index_tuples += match_index_tuples ## remove duplicates by calculating quaternions necessary to align atoms, applying it to the search pattern and if # there is symmetry or chirality, eliminating possible matches where the atoms rotate into different places than we # found them in the structure. pattern = pattern . copy () pattern . translate ( - pattern . positions [ axisp1_idx ]) search_axis = pattern . positions [ axisp2_idx ] if len ( pattern ) > 2 and opoint_idx is None : # note that we find an orientation point if there are nore than two atoms in the search pattern, but it is still # possible that all the atoms like on the search axis. In that, case a point on the axis will be returned and # there is an unnecessary final rotation to \"align\" that point. opoint_idx = position_index_farthest_from_axis ( search_axis , pattern ) grouped_tuples = group_duplicates ( all_match_index_tuples , key = lambda m : tuple ( sorted ([ index_mapper [ i ] % len ( structure ) for i in m ]))) grouped_tuples2 = [] good_match_index_tuples = [] good_match_quats = [] for _ , match_tuples in grouped_tuples . items (): quats = [] good_indices = [] for i , match_tuple in enumerate ( match_tuples ): atom_positions = np . array ([ s_positions [ index_mapper [ m ]] for m in match_tuple ]) q = R . identity () if len ( atom_positions ) > 1 : # the first quaternion aligns the search pattern axis points with the axis points # found in the structure match_axis = atom_positions [ axisp2_idx ] - atom_positions [ axisp1_idx ] q = quaternion_from_two_vectors ( search_axis , match_axis ) if len ( atom_positions ) > 2 : # the second quaternion is a rotation around the found axis in the structure and # aligns the orientation axis point to its placement in the structure. match_orientation_point = atom_positions [ opoint_idx ] - atom_positions [ axisp1_idx ] rotated_orientation_point = q . apply ( pattern . positions [ opoint_idx ]) q = quaternion_from_two_vectors_around_axis ( rotated_orientation_point , match_orientation_point , match_axis ) * q quats . append ( q ) chk_pattern = pattern . copy () chk_pattern . positions = q . apply ( chk_pattern . positions ) chk_pattern . translate ( atom_positions [ axisp1_idx ]) if positions_are_unchanged ( atom_positions , chk_pattern . positions , max_delta = atol , verbose = verbose ): good_indices . append ( i ) if len ( good_indices ) > 1 : # Likely it is because of symmetry if we found more than one good match. Randomly choose one. match_chosen = random . choice ( good_indices ) good_match_index_tuples . append ( match_tuples [ match_chosen ]) good_match_quats . append ( quats [ match_chosen ]) elif len ( good_indices ) == 1 : # Found one good match; either we have no symmetry, or we have symmetry where only one numbering of the # atoms can be rotated into place good_match_index_tuples . append ( match_tuples [ good_indices [ 0 ]]) good_match_quats . append ( quats [ good_indices [ 0 ]]) else : print ( \"\"\"WARNING: Search pattern was matched, but there is no possible way to rotate the search patttern to meet the match pattern. This is likely due to finding a match of the opposite chirality. \"\"\" , file = sys . stderr ) match_index_tuples_in_uc = [ tuple ([ index_mapper [ m ] % len ( structure ) for m in match ]) for match in good_match_index_tuples ] if return_positions_and_quats : match_index_tuple_positions = np . array ([[ s_positions [ index_mapper [ m ]] for m in match ] for match in good_match_index_tuples ]) return match_index_tuples_in_uc , match_index_tuple_positions , np . array ( good_match_quats ) else : return match_index_tuples_in_uc get_types_ss_map_limited_near_uc ( structure , length ) structure: length: the length of the longest dimension of the search pattern creates master lists of indices, types and positions, for all atoms in the structure and all atoms across the PBCs. Limits atoms across PBCs to those that are within a distance of the boundary that is less than the length of the search pattern (i.e. atoms further away from the boundary than this will never match the search pattern). Source code in mofun/mofun.py def get_types_ss_map_limited_near_uc ( structure , length ): \"\"\" structure: length: the length of the longest dimension of the search pattern creates master lists of indices, types and positions, for all atoms in the structure and all atoms across the PBCs. Limits atoms across PBCs to those that are within a distance of the boundary that is less than the length of the search pattern (i.e. atoms further away from the boundary than this will never match the search pattern). \"\"\" cell = structure . cell uc_offsets = uc_neighbor_offsets ( cell ) # move (0., 0., 0.) to be at the 0 index uc_offsets [ np . where ( np . all ( uc_offsets == ( 0 , 0 , 0 ), axis = 1 ))[ 0 ][ 0 ]] = uc_offsets [ 0 ] uc_offsets [ 0 ] = ( 0.0 , 0.0 , 0.0 ) s_positions = [ structure . positions + uc_offset for uc_offset in uc_offsets ] s_positions = np . array ([ x for y in s_positions for x in y ]) s_types = list ( structure . elements ) * len ( uc_offsets ) index_mapper = [] s_pos_view = [] s_types_view = [] is_triclinic = not ( np . diag ( cell ) * np . identity ( 3 ) == cell ) . all () if is_triclinic : # search within triclinic space + buffer by looking at three planes that go through origin # normal vectors for planes: xy, xz, yz nvs = np . array ([ np . cross ( cell [ 0 ], cell [ 1 ]), np . cross ( cell [ 0 ], cell [ 2 ]), np . cross ( cell [ 1 ], cell [ 2 ])]) nvnorms = np . linalg . norm ( nvs , axis = 1 ) planedists = np . abs ( np . array ([ np . dot ( cell [ 2 ], nvs [ 0 ]) / nvnorms [ 0 ], np . dot ( cell [ 1 ], nvs [ 1 ]) / nvnorms [ 1 ], np . dot ( cell [ 0 ], nvs [ 2 ]) / nvnorms [ 2 ]])) # calculate distance to center point; from a plane boundary to inside the unit cell # (inwards) should have a negative distance. If not, we will multiply the distances below # by -1 to account for this. centerpos = cell . sum ( axis = 0 ) / 2 centerdist = np . dot ( nvs , centerpos ) nmults = - centerdist / np . abs ( centerdist ) for i , pos in enumerate ( s_positions ): if (( - planedists [ 0 ] - length <= nmults [ 0 ] * np . dot ( nvs [ 0 ], pos ) / nvnorms [ 0 ] <= length ) and ( - planedists [ 1 ] - length <= nmults [ 1 ] * np . dot ( nvs [ 1 ], pos ) / nvnorms [ 1 ] <= length ) and ( - planedists [ 2 ] - length <= nmults [ 2 ] * np . dot ( nvs [ 2 ], pos ) / nvnorms [ 2 ] <= length )): index_mapper . append ( i ) s_pos_view . append ( pos ) s_types_view . append ( s_types [ i ]) else : # orthorhombic cell = list ( np . diag ( cell )) for i , pos in enumerate ( s_positions ): if ( pos [ 0 ] >= - length and pos [ 0 ] < length + cell [ 0 ] and pos [ 1 ] >= - length and pos [ 1 ] < length + cell [ 1 ] and pos [ 2 ] >= - length and pos [ 2 ] < length + cell [ 2 ]): index_mapper . append ( i ) s_pos_view . append ( pos ) s_types_view . append ( s_types [ i ]) return s_types_view , index_mapper , s_pos_view , s_positions replace_pattern_in_structure ( structure , search_pattern , replace_pattern , replace_fraction = 1.0 , atol = 0.05 , axisp1_idx = 0 , axisp2_idx =- 1 , opoint_idx = None , return_num_matches = False , replace_all = False , verbose = False , positions_check_max_delta = 0.1 , ignore_atoms_should_not_be_deleted_twice = False ) Replaces all instances of pattern in structure with the replace_pattern . Works across periodic boundary conditions. WARNING: the replace pattern MUST be on the same coordinate system as the search_pattern. If there are atoms that remain the same between the search and replace patterns, they must have the exact same coordinates. If these were to be offset, or moved, then when the replacement pattern gets inserted into the structure, then the replacement will also be offset. Parameters: Name Type Description Default structure Atoms an Atoms object to search in. required search_pattern Atoms an Atoms object to search for. required replace_pattern Atoms an Atoms object to search for. required replace_fraction float how many instances of the search_pattern found in the structure get replaced by the replace pattern. 1.0 atol float absolute tolerance in Angstroms for atom posistions to be considered matching. 0.05 axisp1_idx float index in search_pattern of first point defining the directional axis of the search_pattern. 0 axisp2_idx float index in search_pattern of second point defining the directional axis of the search_pattern. -1 opoint_idx float index in search_pattern of third point defining the orientational axis of the search_pattern. None replace_all bool replaces all atoms even if positions and elements match exactly False verbose bool print debugging info. False ignore_atoms_should_not_be_deleted_twice bool don't raise an AtomsShouldNotBeDeletedTwice exception when two matches would delete the same atoms. False Returns: Type Description Atoms the structure after search_pattern is replaced by replace_pattern. Source code in mofun/mofun.py @suppress_warnings def replace_pattern_in_structure ( structure , search_pattern , replace_pattern , replace_fraction = 1.0 , atol = 5e-2 , axisp1_idx = 0 , axisp2_idx =- 1 , opoint_idx = None , return_num_matches = False , replace_all = False , verbose = False , positions_check_max_delta = 0.1 , ignore_atoms_should_not_be_deleted_twice = False ): \"\"\"Replaces all instances of `pattern` in `structure` with the `replace_pattern`. Works across periodic boundary conditions. WARNING: the replace pattern _MUST_ be on the same coordinate system as the search_pattern. If there are atoms that remain the same between the search and replace patterns, they must have the exact same coordinates. If these were to be offset, or moved, then when the replacement pattern gets inserted into the structure, then the replacement will also be offset. Args: structure (Atoms): an Atoms object to search in. search_pattern (Atoms): an Atoms object to search for. replace_pattern (Atoms): an Atoms object to search for. replace_fraction (float): how many instances of the search_pattern found in the structure get replaced by the replace pattern. atol (float): absolute tolerance in Angstroms for atom posistions to be considered matching. axisp1_idx (float): index in search_pattern of first point defining the directional axis of the search_pattern. axisp2_idx (float): index in search_pattern of second point defining the directional axis of the search_pattern. opoint_idx (float): index in search_pattern of third point defining the orientational axis of the search_pattern. replace_all (bool): replaces all atoms even if positions and elements match exactly verbose (bool): print debugging info. ignore_atoms_should_not_be_deleted_twice (bool): don't raise an AtomsShouldNotBeDeletedTwice exception when two matches would delete the same atoms. Returns: Atoms: the structure after search_pattern is replaced by replace_pattern. \"\"\" search_pattern = search_pattern . copy () replace_pattern = replace_pattern . copy () # translate both search and replace patterns so that first atom of search pattern is at the origin replace_pattern . translate ( - search_pattern . positions [ axisp1_idx ]) search_pattern . translate ( - search_pattern . positions [ axisp1_idx ]) match_indices , match_positions , quats = find_pattern_in_structure ( structure , search_pattern , atol = atol , axisp1_idx = axisp1_idx , axisp2_idx = axisp2_idx , opoint_idx = opoint_idx , return_positions_and_quats = True , verbose = verbose ) if replace_fraction < 1.0 : replace_indices = random . sample ( list ( range ( len ( match_positions ))), k = round ( replace_fraction * len ( match_positions ))) match_indices = [ match_indices [ i ] for i in replace_indices ] match_positions = match_positions [ replace_indices ] quats = quats [ replace_indices ] if verbose : print ( \"match_indices / positions: \" , match_indices , match_positions ) replace2search_pattern_map = { k : v for ( k , v ) in find_unchanged_atom_pairs ( replace_pattern , search_pattern )} new_structure = structure . copy () to_delete = set () if len ( replace_pattern ) == 0 : to_delete |= set ([ idx for match in match_indices for idx in match ]) else : offsets = new_structure . extend_types ( replace_pattern ) for m_i , atom_positions in enumerate ( match_positions ): q = quats [ m_i ] new_atoms = replace_pattern . copy () new_atoms . positions = q . apply ( new_atoms . positions ) new_atoms . translate ( atom_positions [ axisp1_idx ]) new_atoms . positions %= np . diag ( new_structure . cell ) if verbose : print ( \"new atoms after translate: \\n \" , new_atoms . positions ) structure_index_map = {} if not replace_all : structure_index_map = { k : match_indices [ m_i ][ v ] for k , v in replace2search_pattern_map . items ()} new_structure . extend ( new_atoms , offsets = offsets , structure_index_map = structure_index_map ) else : new_structure . extend ( new_atoms , offsets = offsets ) to_delete_linker = set ( match_indices [ m_i ]) - set ( structure_index_map . values ()) if ( to_delete . isdisjoint ( to_delete_linker ) or ignore_atoms_should_not_be_deleted_twice ): to_delete |= set ( to_delete_linker ) else : raise AtomsShouldNotBeDeletedTwice () del ( new_structure [ list ( to_delete )]) if return_num_matches : return new_structure , len ( match_indices ) else : return new_structure","title":"Mofun"},{"location":"reference/mofun/#mofun.mofun.find_pattern_in_structure","text":"Looks for instances of pattern in structure , where a match in the structure has the same number of atoms, the same elements and the same relative coordinates as in pattern . Returns a list of tuples, one tuple per match found in structure where each tuple has the size len(pattern) and contains the indices in the structure that matched the pattern. If return_positions_and_quats=True then two additional lists are returned containing positions for each matched index for each match, and the quaternions required to rotate the search pattern to the match pattern. Parameters: Name Type Description Default structure Atoms an Atoms object to search in. required pattern Atoms an Atoms object to search for. required axisp1_idx float index in search_pattern of first point defining the directional axis of the search_pattern. May help with performance for large problems. 0 axisp2_idx float index in search_pattern of second point defining the directional axis of the search_pattern. May help with performance for large problems. -1 opoint_idx float index in search_pattern of the orientation point that we will use to align the search pattern (the search pattern will be rotated so that the orientation point in the search pattern will have the same coordinates as the same point in the match pattern). None return_positions_and_quats bool additionally returns the positions for each index and the quaternions that rotation the search pattern to the match pattern. False atol float the absolute tolerance (how close an atom must be in the structure to the position in pattern to be considered a match). 0.05 verbose bool print debugging info. False Returns: Type Description List [tuple(len(pattern))], {List [tuple(len(pattern))], List [scipy.spatial.transform.Rotation]} returns a list of tuples of size len(pattern) containing the indices in the structure that matched the pattern, one tuple per each match, and optionally (if return_positions_and_quats is True) a corresponding list of tuples with positions instead of indices, and a list of quaternions (scipy.spatial.transform.Rotation), one per each match. Source code in mofun/mofun.py @suppress_warnings def find_pattern_in_structure ( structure , pattern , axisp1_idx = 0 , axisp2_idx =- 1 , opoint_idx = None , return_positions_and_quats = False , atol = 5e-2 , verbose = False ): \"\"\"Looks for instances of `pattern` in `structure`, where a match in the structure has the same number of atoms, the same elements and the same relative coordinates as in `pattern`. Returns a list of tuples, one tuple per match found in `structure` where each tuple has the size `len(pattern)` and contains the indices in the structure that matched the pattern. If `return_positions_and_quats=True` then two additional lists are returned containing positions for each matched index for each match, and the quaternions required to rotate the search pattern to the match pattern. Args: structure (Atoms): an Atoms object to search in. pattern (Atoms): an Atoms object to search for. axisp1_idx (float): index in search_pattern of first point defining the directional axis of the search_pattern. May help with performance for large problems. axisp2_idx (float): index in search_pattern of second point defining the directional axis of the search_pattern. May help with performance for large problems. opoint_idx (float): index in search_pattern of the orientation point that we will use to align the search pattern (the search pattern will be rotated so that the orientation point in the search pattern will have the same coordinates as the same point in the match pattern). return_positions_and_quats (bool): additionally returns the positions for each index and the quaternions that rotation the search pattern to the match pattern. atol (float): the absolute tolerance (how close an atom must be in the structure to the position in pattern to be considered a match). verbose (bool): print debugging info. Returns: List [tuple(len(pattern))], {List [tuple(len(pattern))], List [scipy.spatial.transform.Rotation]} : returns a list of tuples of size `len(pattern)` containing the indices in the structure that matched the pattern, one tuple per each match, and optionally (if return_positions_and_quats is True) a corresponding list of tuples with positions instead of indices, and a list of quaternions (scipy.spatial.transform.Rotation), one per each match. \"\"\" if verbose : print ( \"calculating point distances...\" ) p_ss = distance . cdist ( pattern . positions , pattern . positions , \"sqeuclidean\" ) pattern_length = p_ss . max () ** 0.5 + 2 * atol s_types_view , index_mapper , s_pos_view , s_positions = get_types_ss_map_limited_near_uc ( structure , pattern_length ) atoms_by_type = atoms_by_type_dict ( s_types_view ) # created sorted coords array for creating search subsets p = np . array ( sorted ([( * r , i ) for i , r in enumerate ( s_pos_view )])) # Search instances of first atom in a search pattern # 0,0,0 uc atoms are always indexed first from 0 to # atoms in structure. starting_atoms = [ idx for idx in atoms_of_type ( s_types_view [ 0 : len ( structure )], pattern . elements [ 0 ])] if verbose : print ( \"round %d ( %d ) [ %s ]: \" % ( 0 , len ( starting_atoms ), pattern . elements [ 0 ]), starting_atoms ) def get_nearby_atoms ( p , s_pos_view , pattern_length , a ): p1 = p [( p [:, 0 ] <= s_pos_view [ a ][ 0 ] + pattern_length ) & ( p [:, 0 ] >= s_pos_view [ a ][ 0 ] - pattern_length )] p2 = p1 [( p1 [:, 1 ] <= s_pos_view [ a ][ 1 ] + pattern_length ) & ( p1 [:, 1 ] >= s_pos_view [ a ][ 1 ] - pattern_length )] return ( p2 [( p2 [:, 2 ] <= s_pos_view [ a ][ 2 ] + pattern_length ) & ( p2 [:, 2 ] >= s_pos_view [ a ][ 2 ] - pattern_length )]) pattern_elements = pattern . elements all_match_index_tuples = [] for a_idx , a in enumerate ( starting_atoms ): match_index_tuples = [[ a ]] nearby = get_nearby_atoms ( p , s_pos_view , pattern_length , a ) nearby_atom_indices = nearby [:, 3 ] . astype ( np . int32 ) nearby_positions = nearby [:, 0 : 3 ] idx2ssidx = { atom_idx : i for i , atom_idx in enumerate ( nearby_atom_indices )} s_ss = distance . cdist ( nearby_positions , nearby_positions , \"sqeuclidean\" ) # start for loop at one since we've searched for starting atoms (index == 0) above for i in range ( 1 , len ( pattern )): if len ( match_index_tuples ) == 0 : break last_match_index_tuples = match_index_tuples match_index_tuples = [] for match in last_match_index_tuples : for ss_idx , atom_idx in enumerate ( nearby_atom_indices ): if s_types_view [ atom_idx ] == pattern_elements [ i ]: found_match = True # check all distances to this new proposed atom for j in range ( 0 , i ): if not math . isclose ( p_ss [ i , j ] ** 0.5 , s_ss [ idx2ssidx [ match [ j ]], ss_idx ] ** 0.5 , abs_tol = atol ): found_match = False break # anything that matches the distance to all prior pattern atoms is a good match so far if found_match : match_index_tuples . append ( match + [ atom_idx ]) if verbose : print ( \"round %d ( %d ) [ %s ]: \" % ( i , len ( match_index_tuples ), pattern . elements [ i ]), match_index_tuples ) if verbose : print ( \"starting atom %d : found %d matches: %s \" % ( a_idx , len ( match_index_tuples ), match_index_tuples )) all_match_index_tuples += match_index_tuples ## remove duplicates by calculating quaternions necessary to align atoms, applying it to the search pattern and if # there is symmetry or chirality, eliminating possible matches where the atoms rotate into different places than we # found them in the structure. pattern = pattern . copy () pattern . translate ( - pattern . positions [ axisp1_idx ]) search_axis = pattern . positions [ axisp2_idx ] if len ( pattern ) > 2 and opoint_idx is None : # note that we find an orientation point if there are nore than two atoms in the search pattern, but it is still # possible that all the atoms like on the search axis. In that, case a point on the axis will be returned and # there is an unnecessary final rotation to \"align\" that point. opoint_idx = position_index_farthest_from_axis ( search_axis , pattern ) grouped_tuples = group_duplicates ( all_match_index_tuples , key = lambda m : tuple ( sorted ([ index_mapper [ i ] % len ( structure ) for i in m ]))) grouped_tuples2 = [] good_match_index_tuples = [] good_match_quats = [] for _ , match_tuples in grouped_tuples . items (): quats = [] good_indices = [] for i , match_tuple in enumerate ( match_tuples ): atom_positions = np . array ([ s_positions [ index_mapper [ m ]] for m in match_tuple ]) q = R . identity () if len ( atom_positions ) > 1 : # the first quaternion aligns the search pattern axis points with the axis points # found in the structure match_axis = atom_positions [ axisp2_idx ] - atom_positions [ axisp1_idx ] q = quaternion_from_two_vectors ( search_axis , match_axis ) if len ( atom_positions ) > 2 : # the second quaternion is a rotation around the found axis in the structure and # aligns the orientation axis point to its placement in the structure. match_orientation_point = atom_positions [ opoint_idx ] - atom_positions [ axisp1_idx ] rotated_orientation_point = q . apply ( pattern . positions [ opoint_idx ]) q = quaternion_from_two_vectors_around_axis ( rotated_orientation_point , match_orientation_point , match_axis ) * q quats . append ( q ) chk_pattern = pattern . copy () chk_pattern . positions = q . apply ( chk_pattern . positions ) chk_pattern . translate ( atom_positions [ axisp1_idx ]) if positions_are_unchanged ( atom_positions , chk_pattern . positions , max_delta = atol , verbose = verbose ): good_indices . append ( i ) if len ( good_indices ) > 1 : # Likely it is because of symmetry if we found more than one good match. Randomly choose one. match_chosen = random . choice ( good_indices ) good_match_index_tuples . append ( match_tuples [ match_chosen ]) good_match_quats . append ( quats [ match_chosen ]) elif len ( good_indices ) == 1 : # Found one good match; either we have no symmetry, or we have symmetry where only one numbering of the # atoms can be rotated into place good_match_index_tuples . append ( match_tuples [ good_indices [ 0 ]]) good_match_quats . append ( quats [ good_indices [ 0 ]]) else : print ( \"\"\"WARNING: Search pattern was matched, but there is no possible way to rotate the search patttern to meet the match pattern. This is likely due to finding a match of the opposite chirality. \"\"\" , file = sys . stderr ) match_index_tuples_in_uc = [ tuple ([ index_mapper [ m ] % len ( structure ) for m in match ]) for match in good_match_index_tuples ] if return_positions_and_quats : match_index_tuple_positions = np . array ([[ s_positions [ index_mapper [ m ]] for m in match ] for match in good_match_index_tuples ]) return match_index_tuples_in_uc , match_index_tuple_positions , np . array ( good_match_quats ) else : return match_index_tuples_in_uc","title":"find_pattern_in_structure()"},{"location":"reference/mofun/#mofun.mofun.get_types_ss_map_limited_near_uc","text":"structure: length: the length of the longest dimension of the search pattern creates master lists of indices, types and positions, for all atoms in the structure and all atoms across the PBCs. Limits atoms across PBCs to those that are within a distance of the boundary that is less than the length of the search pattern (i.e. atoms further away from the boundary than this will never match the search pattern). Source code in mofun/mofun.py def get_types_ss_map_limited_near_uc ( structure , length ): \"\"\" structure: length: the length of the longest dimension of the search pattern creates master lists of indices, types and positions, for all atoms in the structure and all atoms across the PBCs. Limits atoms across PBCs to those that are within a distance of the boundary that is less than the length of the search pattern (i.e. atoms further away from the boundary than this will never match the search pattern). \"\"\" cell = structure . cell uc_offsets = uc_neighbor_offsets ( cell ) # move (0., 0., 0.) to be at the 0 index uc_offsets [ np . where ( np . all ( uc_offsets == ( 0 , 0 , 0 ), axis = 1 ))[ 0 ][ 0 ]] = uc_offsets [ 0 ] uc_offsets [ 0 ] = ( 0.0 , 0.0 , 0.0 ) s_positions = [ structure . positions + uc_offset for uc_offset in uc_offsets ] s_positions = np . array ([ x for y in s_positions for x in y ]) s_types = list ( structure . elements ) * len ( uc_offsets ) index_mapper = [] s_pos_view = [] s_types_view = [] is_triclinic = not ( np . diag ( cell ) * np . identity ( 3 ) == cell ) . all () if is_triclinic : # search within triclinic space + buffer by looking at three planes that go through origin # normal vectors for planes: xy, xz, yz nvs = np . array ([ np . cross ( cell [ 0 ], cell [ 1 ]), np . cross ( cell [ 0 ], cell [ 2 ]), np . cross ( cell [ 1 ], cell [ 2 ])]) nvnorms = np . linalg . norm ( nvs , axis = 1 ) planedists = np . abs ( np . array ([ np . dot ( cell [ 2 ], nvs [ 0 ]) / nvnorms [ 0 ], np . dot ( cell [ 1 ], nvs [ 1 ]) / nvnorms [ 1 ], np . dot ( cell [ 0 ], nvs [ 2 ]) / nvnorms [ 2 ]])) # calculate distance to center point; from a plane boundary to inside the unit cell # (inwards) should have a negative distance. If not, we will multiply the distances below # by -1 to account for this. centerpos = cell . sum ( axis = 0 ) / 2 centerdist = np . dot ( nvs , centerpos ) nmults = - centerdist / np . abs ( centerdist ) for i , pos in enumerate ( s_positions ): if (( - planedists [ 0 ] - length <= nmults [ 0 ] * np . dot ( nvs [ 0 ], pos ) / nvnorms [ 0 ] <= length ) and ( - planedists [ 1 ] - length <= nmults [ 1 ] * np . dot ( nvs [ 1 ], pos ) / nvnorms [ 1 ] <= length ) and ( - planedists [ 2 ] - length <= nmults [ 2 ] * np . dot ( nvs [ 2 ], pos ) / nvnorms [ 2 ] <= length )): index_mapper . append ( i ) s_pos_view . append ( pos ) s_types_view . append ( s_types [ i ]) else : # orthorhombic cell = list ( np . diag ( cell )) for i , pos in enumerate ( s_positions ): if ( pos [ 0 ] >= - length and pos [ 0 ] < length + cell [ 0 ] and pos [ 1 ] >= - length and pos [ 1 ] < length + cell [ 1 ] and pos [ 2 ] >= - length and pos [ 2 ] < length + cell [ 2 ]): index_mapper . append ( i ) s_pos_view . append ( pos ) s_types_view . append ( s_types [ i ]) return s_types_view , index_mapper , s_pos_view , s_positions","title":"get_types_ss_map_limited_near_uc()"},{"location":"reference/mofun/#mofun.mofun.replace_pattern_in_structure","text":"Replaces all instances of pattern in structure with the replace_pattern . Works across periodic boundary conditions. WARNING: the replace pattern MUST be on the same coordinate system as the search_pattern. If there are atoms that remain the same between the search and replace patterns, they must have the exact same coordinates. If these were to be offset, or moved, then when the replacement pattern gets inserted into the structure, then the replacement will also be offset. Parameters: Name Type Description Default structure Atoms an Atoms object to search in. required search_pattern Atoms an Atoms object to search for. required replace_pattern Atoms an Atoms object to search for. required replace_fraction float how many instances of the search_pattern found in the structure get replaced by the replace pattern. 1.0 atol float absolute tolerance in Angstroms for atom posistions to be considered matching. 0.05 axisp1_idx float index in search_pattern of first point defining the directional axis of the search_pattern. 0 axisp2_idx float index in search_pattern of second point defining the directional axis of the search_pattern. -1 opoint_idx float index in search_pattern of third point defining the orientational axis of the search_pattern. None replace_all bool replaces all atoms even if positions and elements match exactly False verbose bool print debugging info. False ignore_atoms_should_not_be_deleted_twice bool don't raise an AtomsShouldNotBeDeletedTwice exception when two matches would delete the same atoms. False Returns: Type Description Atoms the structure after search_pattern is replaced by replace_pattern. Source code in mofun/mofun.py @suppress_warnings def replace_pattern_in_structure ( structure , search_pattern , replace_pattern , replace_fraction = 1.0 , atol = 5e-2 , axisp1_idx = 0 , axisp2_idx =- 1 , opoint_idx = None , return_num_matches = False , replace_all = False , verbose = False , positions_check_max_delta = 0.1 , ignore_atoms_should_not_be_deleted_twice = False ): \"\"\"Replaces all instances of `pattern` in `structure` with the `replace_pattern`. Works across periodic boundary conditions. WARNING: the replace pattern _MUST_ be on the same coordinate system as the search_pattern. If there are atoms that remain the same between the search and replace patterns, they must have the exact same coordinates. If these were to be offset, or moved, then when the replacement pattern gets inserted into the structure, then the replacement will also be offset. Args: structure (Atoms): an Atoms object to search in. search_pattern (Atoms): an Atoms object to search for. replace_pattern (Atoms): an Atoms object to search for. replace_fraction (float): how many instances of the search_pattern found in the structure get replaced by the replace pattern. atol (float): absolute tolerance in Angstroms for atom posistions to be considered matching. axisp1_idx (float): index in search_pattern of first point defining the directional axis of the search_pattern. axisp2_idx (float): index in search_pattern of second point defining the directional axis of the search_pattern. opoint_idx (float): index in search_pattern of third point defining the orientational axis of the search_pattern. replace_all (bool): replaces all atoms even if positions and elements match exactly verbose (bool): print debugging info. ignore_atoms_should_not_be_deleted_twice (bool): don't raise an AtomsShouldNotBeDeletedTwice exception when two matches would delete the same atoms. Returns: Atoms: the structure after search_pattern is replaced by replace_pattern. \"\"\" search_pattern = search_pattern . copy () replace_pattern = replace_pattern . copy () # translate both search and replace patterns so that first atom of search pattern is at the origin replace_pattern . translate ( - search_pattern . positions [ axisp1_idx ]) search_pattern . translate ( - search_pattern . positions [ axisp1_idx ]) match_indices , match_positions , quats = find_pattern_in_structure ( structure , search_pattern , atol = atol , axisp1_idx = axisp1_idx , axisp2_idx = axisp2_idx , opoint_idx = opoint_idx , return_positions_and_quats = True , verbose = verbose ) if replace_fraction < 1.0 : replace_indices = random . sample ( list ( range ( len ( match_positions ))), k = round ( replace_fraction * len ( match_positions ))) match_indices = [ match_indices [ i ] for i in replace_indices ] match_positions = match_positions [ replace_indices ] quats = quats [ replace_indices ] if verbose : print ( \"match_indices / positions: \" , match_indices , match_positions ) replace2search_pattern_map = { k : v for ( k , v ) in find_unchanged_atom_pairs ( replace_pattern , search_pattern )} new_structure = structure . copy () to_delete = set () if len ( replace_pattern ) == 0 : to_delete |= set ([ idx for match in match_indices for idx in match ]) else : offsets = new_structure . extend_types ( replace_pattern ) for m_i , atom_positions in enumerate ( match_positions ): q = quats [ m_i ] new_atoms = replace_pattern . copy () new_atoms . positions = q . apply ( new_atoms . positions ) new_atoms . translate ( atom_positions [ axisp1_idx ]) new_atoms . positions %= np . diag ( new_structure . cell ) if verbose : print ( \"new atoms after translate: \\n \" , new_atoms . positions ) structure_index_map = {} if not replace_all : structure_index_map = { k : match_indices [ m_i ][ v ] for k , v in replace2search_pattern_map . items ()} new_structure . extend ( new_atoms , offsets = offsets , structure_index_map = structure_index_map ) else : new_structure . extend ( new_atoms , offsets = offsets ) to_delete_linker = set ( match_indices [ m_i ]) - set ( structure_index_map . values ()) if ( to_delete . isdisjoint ( to_delete_linker ) or ignore_atoms_should_not_be_deleted_twice ): to_delete |= set ( to_delete_linker ) else : raise AtomsShouldNotBeDeletedTwice () del ( new_structure [ list ( to_delete )]) if return_num_matches : return new_structure , len ( match_indices ) else : return new_structure","title":"replace_pattern_in_structure()"}]}