{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MOFUN See Atoms for info on Atoms objects and how to use them. See MOFUN for find / replace on Atoms objects.","title":"MOFUN"},{"location":"#mofun","text":"See Atoms for info on Atoms objects and how to use them. See MOFUN for find / replace on Atoms objects.","title":"MOFUN"},{"location":"reference/atoms/","text":"Atoms An Atoms object is a container for all the information required to keep track of a structure and the structure's force field. See the documentation on __init__ or load to see how to create an Atoms object. An Atoms object is made up primarily of numpy arrays and a couple normal lists. Some arrays are per-atom (one entry per atom): atom_types , positions , charges , and groups . Some arrays are per-atom-type (one entry per atom type): atom_type_masses , atom_type_elements , and atom_type_labels . Some arrays are per-bond (one entry per bond): bonds , and bond_types . Some arrays are per-angle (one entry per angle): angles , and angle_types . Some arrays are per-dihedral (one entry per dihedral): dihedrals , and dihedral_types . Some arrays are per-improper (one entry per improper): impropers , and improper_types . Atoms also stores information on the coefficients needed to define each force field term: pair_coeffs , bond_type_coeffs , angle_type_coeffs , dihedral_type_coeffs , and improper_type_coeffs . The *_coeffs variables are lists of strings, where the item index corresponds to the *_type, and the string is the full LAMMPS coeffs definition string. we do not interpret any of the LAMMPS coefficient specifics, we just store it in its original form, i.e. this Angle Coeffs section: Angle Coeffs 1 cosine/periodic 72.500283 -1 1 # C_R O_1 H_ 2 cosine/periodic 277.164705 -1 3 # C_R C_R O_1 would be interpreted like this: angle_type_coeffs= [\"cosine/periodic 72.500283 -1 1 # C_R O_1 H_\", \"cosine/periodic 277.164705 -1 3 # C_R C_R O_1\"] __init__ ( self , atom_types = [], positions = [], charges = [], groups = [], elements = [], atom_type_masses = [], atom_type_elements = [], atom_type_labels = [], bonds = [], bond_types = [], angles = [], angle_types = [], dihedrals = [], dihedral_types = [], impropers = [], improper_types = [], pair_coeffs = [], bond_type_coeffs = [], angle_type_coeffs = [], dihedral_type_coeffs = [], improper_type_coeffs = [], cell = []) special Create an Atoms object. An Atoms object can be created without any atoms using Atoms() . For creating more interesting Atoms objects, there are a few rules to keep in mind. The parameters atom_types , positions , charges , and groups are all lists that should have a size equal to the number of atoms in the system. positions is mandatory; charges , and groups are optional (both default to 0 for each atom) and there are two ways to specify atom types: 1) specify the atom_types and atom_type_elements explicitly, which is how the load_lmpdat method loads Atoms objects from a LAMMPS data file, or 2) specify per-atom elements and and have MOFUN auto-number the atom types for you, which is more convenient when specifying small molecules in code or when loading from other file formats such as CML or CIF which may store element information but not type information. When explicitly setting the types, you must pass atom_types and atom_type_elements . atom_types is a list of int type ids >= 0, one for each atom in the system. atom_type_elements is a list of element names (e.g. \"C\", \"N\", \"Zr\") per atom type . For example, if your system is propane, your atom_types list could be [0, 1, 1, 1] and your atom_type_elements list would then be [\"C\", \"H\"]. To specify per-atom elements, you must pass elements with either a list of elements, such as Atoms(elements=[\"C\", \"C\"], ...) or with a string Atoms(elements=\"CC\", ...) . If you use the elements parameter, then type ids are automatically generated. Passing atom_type_masses is optional, and masses will be inferred from the elements if missing. If you are using atom types with masses that do not correspond to periodic table elements, then you will need to specify the masses explicitly. Passing force field term information for bonds , angles , dihedrals , and impropers is optional, as well as passing force field coefficients for LAMMPS with pair_coeffs , bond_type_coeffs , angle_type_coeffs , dihedral_type_coeffs , and improper_type_coeffs . Examples: a = Atoms() # create an empty Atoms object with no atoms a = Atoms(atom_types=[0], positions=[[0,0,0]]) # create one atom of type 0 a = Atoms(elements=[\"C\"], positions=[[0,0,0]]) # create one Carbon a = Atoms(elements=[\"C\", \"C\"], positions=[[0,0,0], [1,0,0]]) # create two Carbons a = Atoms(elements=\"CC\", positions=[[0,0,0], [1,0,0]]) # create two Carbons using shorthand element notation Parameters: Name Type Description Default atom_types List[int] list of integer type ids, one per atom. [] positions List[Tuple[float, float, float]] list of tuple atom x,y,z coordinates, one per atom. [] charges List[float] list of charges, one per atom. Defaults to 0 for each atom if not passed. [] groups List[int] list of integer groups, one per atom. For LAMMPS this gets mapped to a \"molecule id\". Defaults to 0 for each atom if not passed. [] elements List[str], str either a list of elements, (e.g. [\"C\", \"H\", \"H\", \"H\"]) or an element string (e.g. \"CHHH\") [] atom_type_masses List[float] list of atom type masses, one per atom type. If masses are not passed, they will be inferred from the atom_type_elements . [] atom_type_elements List[str] list of atom type elements, one per atom type. [] atom_type_labels List[str] list of atom type labels, one per atom type. Used in LAMMPS data file line comments as type labels. [] bonds List[Tuple[int, int]] list of bond tuples where each tuple defines a pair of atoms that are bonded. Each value in the tuple is an index of an atom in the atom_* lists. [] bond_types List[int] list of bond type id ints for each bond defined in bonds . [] angles List[Tuple[int, int, int]] list of angle tuples where each tuple defines a triplet of atoms making up the angle. Each value in the tuple is an index of an atom in the atom_* lists. [] angle_types List[int] list of angle type id ints for each angle defined in angles . [] dihedrals List[Tuple[int, int, int, int]] list of dihedral tuples where each dihedral defines a quartet of atoms making up the dihedral. Each value in the tuple is an index of an atom in the atom_* lists. [] dihedral_types List[int] list of dihedral type id ints for each dihedral defined in dihedrals . [] impropers List[Tuple[int, int, int, int]] list of improper tuples where each improper defines a quartet of atoms making up the improper. Each value in the tuple is an index of an atom in the atom_* lists. [] improper_types List[int] list of improper type id ints for each improper defined in impropers . [] pair_coeffs List[str] pair coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per atom type. [] bond_type_coeffs List[str] bond coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per bond type. [] angle_type_coeffs List[str] angle coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per angle type. [] dihedral_type_coeffs List[str] dihedral coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per dihedral type. [] improper_type_coeffs List[str] improper coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per improper type. [] cell Array(3x3 3x3 array of unit cell vectors. [] Returns: Type Description Atoms the atoms object. Source code in mofun/atoms.py def __init__ ( self , atom_types = [], positions = [], charges = [], groups = [], elements = [], atom_type_masses = [], atom_type_elements = [], atom_type_labels = [], bonds = [], bond_types = [], angles = [], angle_types = [], dihedrals = [], dihedral_types = [], impropers = [], improper_types = [], pair_coeffs = [], bond_type_coeffs = [], angle_type_coeffs = [], dihedral_type_coeffs = [], improper_type_coeffs = [], cell = []): \"\"\"Create an Atoms object. An Atoms object can be created without any atoms using `Atoms()`. For creating more interesting Atoms objects, there are a few rules to keep in mind. The parameters `atom_types`, `positions`, `charges`, and `groups` are all lists that should have a size equal to the number of atoms in the system. `positions` is mandatory; `charges`, and `groups` are optional (both default to 0 for each atom) and there are two ways to specify atom types: 1) specify the atom_types and atom_type_elements explicitly, which is how the `load_lmpdat` method loads Atoms objects from a LAMMPS data file, or 2) specify per-atom elements and and have MOFUN auto-number the atom types for you, which is more convenient when specifying small molecules in code or when loading from other file formats such as CML or CIF which may store element information but not type information. When explicitly setting the types, you must pass `atom_types` and `atom_type_elements`. `atom_types` is a list of int type ids >= 0, one for each atom in the system. `atom_type_elements` is a list of element names (e.g. \"C\", \"N\", \"Zr\") per _atom type_. For example, if your system is propane, your atom_types list could be [0, 1, 1, 1] and your atom_type_elements list would then be [\"C\", \"H\"]. To specify per-atom elements, you must pass `elements` with either a list of elements, such as `Atoms(elements=[\"C\", \"C\"], ...)` or with a string `Atoms(elements=\"CC\", ...)`. If you use the `elements` parameter, then type ids are automatically generated. Passing `atom_type_masses` is optional, and masses will be inferred from the elements if missing. If you are using atom types with masses that do not correspond to periodic table elements, then you will need to specify the masses explicitly. Passing force field term information for `bonds`, `angles`, `dihedrals`, and `impropers` is optional, as well as passing force field coefficients for LAMMPS with `pair_coeffs`, `bond_type_coeffs`, `angle_type_coeffs`, `dihedral_type_coeffs`, and `improper_type_coeffs`. Examples: ``` a = Atoms() # create an empty Atoms object with no atoms a = Atoms(atom_types=[0], positions=[[0,0,0]]) # create one atom of type 0 a = Atoms(elements=[\"C\"], positions=[[0,0,0]]) # create one Carbon a = Atoms(elements=[\"C\", \"C\"], positions=[[0,0,0], [1,0,0]]) # create two Carbons a = Atoms(elements=\"CC\", positions=[[0,0,0], [1,0,0]]) # create two Carbons using shorthand element notation ``` Args: atom_types (List[int]): list of integer type ids, one per atom. positions (List[Tuple[float, float, float]]): list of tuple atom x,y,z coordinates, one per atom. charges (List[float]): list of charges, one per atom. Defaults to 0 for each atom if not passed. groups (List[int]): list of integer groups, one per atom. For LAMMPS this gets mapped to a \"molecule id\". Defaults to 0 for each atom if not passed. elements (List[str], str): either a list of elements, (e.g. [\"C\", \"H\", \"H\", \"H\"]) or an element string (e.g. \"CHHH\") atom_type_masses (List[float]): list of atom type masses, one per atom type. If masses are not passed, they will be inferred from the `atom_type_elements`. atom_type_elements (List[str]): list of atom type elements, one per atom type. atom_type_labels (List[str]): list of atom type labels, one per atom type. Used in LAMMPS data file line comments as type labels. bonds (List[Tuple[int, int]]): list of bond tuples where each tuple defines a pair of atoms that are bonded. Each value in the tuple is an index of an atom in the atom_* lists. bond_types (List[int]): list of bond type id ints for each bond defined in `bonds`. angles (List[Tuple[int, int, int]]): list of angle tuples where each tuple defines a triplet of atoms making up the angle. Each value in the tuple is an index of an atom in the atom_* lists. angle_types (List[int]): list of angle type id ints for each angle defined in `angles`. dihedrals (List[Tuple[int, int, int, int]]): list of dihedral tuples where each dihedral defines a quartet of atoms making up the dihedral. Each value in the tuple is an index of an atom in the atom_* lists. dihedral_types (List[int]): list of dihedral type id ints for each dihedral defined in `dihedrals`. impropers (List[Tuple[int, int, int, int]]): list of improper tuples where each improper defines a quartet of atoms making up the improper. Each value in the tuple is an index of an atom in the atom_* lists. improper_types (List[int]): list of improper type id ints for each improper defined in `impropers`. pair_coeffs (List[str]): pair coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per atom type. bond_type_coeffs (List[str]): bond coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per bond type. angle_type_coeffs (List[str]): angle coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per angle type. dihedral_type_coeffs (List[str]): dihedral coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per dihedral type. improper_type_coeffs (List[str]): improper coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per improper type. cell (Array(3x3)): 3x3 array of unit cell vectors. Returns: Atoms: the atoms object. \"\"\" self . atom_type_masses = np . array ( atom_type_masses , ndmin = 1 ) self . positions = np . array ( positions , dtype = float , ndmin = 1 ) self . cell = np . array ( cell ) self . bonds = np . array ( bonds , dtype = int ) self . bond_types = np . array ( bond_types , dtype = int ) self . angles = np . array ( angles , dtype = int ) self . angle_types = np . array ( angle_types , dtype = int ) self . dihedrals = np . array ( dihedrals , dtype = int ) self . dihedral_types = np . array ( dihedral_types , dtype = int ) self . impropers = np . array ( impropers , dtype = int ) self . improper_types = np . array ( improper_types , dtype = int ) self . pair_coeffs = np . array ( pair_coeffs ) self . bond_type_coeffs = np . array ( bond_type_coeffs ) self . angle_type_coeffs = np . array ( angle_type_coeffs ) self . dihedral_type_coeffs = np . array ( dihedral_type_coeffs ) self . improper_type_coeffs = np . array ( improper_type_coeffs ) if len ( charges ) > 0 : self . charges = np . array ( charges , dtype = float ) else : self . charges = np . zeros ( len ( self . positions ), dtype = float ) if len ( groups ) > 0 : self . groups = np . array ( groups , dtype = int ) else : self . groups = np . zeros ( len ( self . positions ), dtype = int ) # load atom_types and atom_type_elements if len ( atom_types ) > 0 : # default case or a __getitem__ subset self . atom_types = np . array ( atom_types ) self . atom_type_elements = atom_type_elements elif len ( elements ) > 0 : # from element array, such as from ASE atoms or read CML # i.e. Propane ['C', 'H', 'H', 'H', 'C', 'H', 'H', 'C', 'H', 'H', 'H']: # or from element string, i.e. Propane \"CHHHCHHCHHH\" (shorthand): if isinstance ( elements , str ): elements = list ( Formula ( elements )) # preserve order of types self . atom_type_elements = list ( dict . fromkeys ( elements ) . keys ()) self . atom_types = np . array ([ self . atom_type_elements . index ( s ) for s in elements ]) else : # no atom_type_elements or elements passed # this should be the `Atoms()` case; if not, it will fail the asserts below self . atom_types = np . array ([], ndmin = 1 ) self . atom_type_elements = [] # automatically determine masses from elements if masses are not passed if len ( self . atom_type_masses ) == 0 and len ( self . atom_type_elements ) > 0 : self . atom_type_masses = [ ATOMIC_MASSES [ s ] for s in self . atom_type_elements ] if len ( atom_type_labels ) > 0 : self . atom_type_labels = atom_type_labels else : print ( \"WARNING: using the atom elements as the atom_type_labels since labels were not supplied.\" ) # use default atom types equal to the element; this may not be unique! self . atom_type_labels = self . atom_type_elements self . assert_arrays_are_consistent_sizes () extend ( self , other , offsets = None , structure_index_map = {}, verbose = False ) Adds other Atoms object's arrays to its own. The default behavior is for all the types and params from other structure to be appended to this structure. Alternatively, an offsets tuple may be passed with the results of calling extend_types(). No new types will be added, but the newly added atoms, bonds, etc will refer to types by their value in the other Atoms object plus the offset. Use this when you are adding the same set of atoms multiple times, or if your other atoms already share the same type ids as this object. For the later case, the tuple (0,0,0,0) may be passed in. Parameters: Name Type Description Default other Atoms atoms to add to self required offsets an offsets tuple with the results of calling extend_types(). None structure_index_map dictionary where key is an index in other and value is an index in self, where entries only exist if the position and element of the entries are identical and can be considered to be the same atom. {} verbose bool print debugging info. False Source code in mofun/atoms.py def extend ( self , other , offsets = None , structure_index_map = {}, verbose = False ): \"\"\"Adds other Atoms object's arrays to its own. The default behavior is for all the types and params from other structure to be appended to this structure. Alternatively, an offsets tuple may be passed with the results of calling extend_types(). No new types will be added, but the newly added atoms, bonds, etc will refer to types by their value in the other Atoms object plus the offset. Use this when you are adding the same set of atoms multiple times, or if your other atoms already share the same type ids as this object. For the later case, the tuple (0,0,0,0) may be passed in. Args: other (Atoms): atoms to add to self offsets: an offsets tuple with the results of calling extend_types(). structure_index_map: dictionary where key is an index in other and value is an index in self, where entries only exist if the position and element of the entries are identical and can be considered to be the same atom. verbose (bool): print debugging info. \"\"\" atom_idx_offset = len ( self . positions ) if offsets is None : if verbose : print ( \"auto offset: extending types\" ) offsets = self . extend_types ( other ) # update atom types for atoms that are already part of self Atoms object for other_index , self_index in structure_index_map . items (): self . atom_types [ self_index ] = other . atom_types [ other_index ] + offsets [ 0 ] # add atoms that are not part of self Atoms object atoms_to_add = [ i for i in range ( len ( other )) if i not in structure_index_map . keys ()] self . positions = np . append ( self . positions , other . positions [ atoms_to_add ], axis = 0 ) self . atom_types = np . append ( self . atom_types , other . atom_types [ atoms_to_add ] + offsets [ 0 ]) self . charges = np . append ( self . charges , other . charges [ atoms_to_add ]) self . groups = np . append ( self . groups , other . groups [ atoms_to_add ]) # update structure index map structure_index_map2 = { a : i + atom_idx_offset for i , a in enumerate ( atoms_to_add )} structure_index_map2 . update ( structure_index_map ) convert2structureindex = np . vectorize ( structure_index_map2 . get ) def find_existing_topo ( topo , new_topo ): \"\"\" find existing topo tuples between the same atoms as a new topo set. Used to allow an override of an existing force field term by finding old terms between the same atoms to delete\"\"\" existing_topo = [ tuple ( x ) for x in topo ] new_topo_tuples = [ tuple ( x ) for x in new_topo ] existing_topo_indices = [ existing_topo . index ( b ) for b in new_topo_tuples if b in existing_topo ] return existing_topo_indices if len ( other . bonds ) > 0 : new_bonds = convert2structureindex ( other . bonds ) existing_bond_indices = find_existing_topo ( self . bonds , new_bonds ) self . bonds = np . append ( self . bonds , new_bonds ) . reshape (( - 1 , 2 )) self . bond_types = np . append ( self . bond_types , other . bond_types + offsets [ 1 ]) self . bonds = np . delete ( self . bonds , existing_bond_indices , axis = 0 ) self . bond_types = np . delete ( self . bond_types , existing_bond_indices ) if len ( other . angles ) > 0 : new_angles = convert2structureindex ( other . angles ) existing_angle_indices = find_existing_topo ( self . angles , new_angles ) self . angles = np . append ( self . angles , new_angles ) . reshape (( - 1 , 3 )) self . angle_types = np . append ( self . angle_types , other . angle_types + offsets [ 2 ]) self . angles = np . delete ( self . angles , existing_angle_indices , axis = 0 ) self . angle_types = np . delete ( self . angle_types , existing_angle_indices ) if len ( other . dihedrals ) > 0 : new_dihedrals = convert2structureindex ( other . dihedrals ) existing_dihedral_indices = find_existing_topo ( self . dihedrals , new_dihedrals ) self . dihedrals = np . append ( self . dihedrals , new_dihedrals ) . reshape (( - 1 , 4 )) self . dihedral_types = np . append ( self . dihedral_types , other . dihedral_types + offsets [ 3 ]) self . dihedrals = np . delete ( self . dihedrals , existing_dihedral_indices , axis = 0 ) self . dihedral_types = np . delete ( self . dihedral_types , existing_dihedral_indices ) if len ( other . impropers ) > 0 : new_impropers = convert2structureindex ( other . impropers ) existing_improper_indices = find_existing_topo ( self . impropers , new_impropers ) self . impropers = np . append ( self . impropers , new_impropers ) . reshape (( - 1 , 4 )) self . improper_types = np . append ( self . improper_types , other . improper_types + offsets [ 4 ]) self . impropers = np . delete ( self . impropers , existing_improper_indices , axis = 0 ) self . improper_types = np . delete ( self . improper_types , existing_improper_indices ) self . assert_arrays_are_consistent_sizes () from_ase_atoms ( atoms ) classmethod Create an Atoms object from an ASE Atoms object. Only supports importing the atom positions, elements, and the unit cell. Parameters: Name Type Description Default atoms ASE Atoms object atoms to load from required Returns: Type Description Atoms atoms loaded from an ASE Atoms object. Source code in mofun/atoms.py @classmethod def from_ase_atoms ( cls , atoms ): \"\"\"Create an Atoms object from an ASE Atoms object. Only supports importing the atom positions, elements, and the unit cell. Args: atoms (ASE Atoms object): atoms to load from Returns: Atoms: atoms loaded from an ASE Atoms object. \"\"\" return cls ( elements = atoms . symbols , positions = atoms . positions , cell = atoms . cell ) load ( f , filetype = None , ** kwargs ) classmethod Creates an Atoms object from either a path or a file object and filetype. Can load any of the supported types: lammps data file: \"lmpdat\" cif cml Only the lammps data file and cif support reading from a file object, presently, due to the other formats depending on external library support. Parameters: Name Type Description Default f Str or Path or File either a path to a file or an open File to load from required filetype Str filetype ('lmpdat', 'cif', or 'cml') of passed f File object, or explicit filetype to override default filetype implied from file extension. None kwargs keyword args passed on to individual load functions. {} Source code in mofun/atoms.py @classmethod def load ( cls , f , filetype = None , ** kwargs ): \"\"\"Creates an Atoms object from either a path or a file object and filetype. Can load any of the supported types: - lammps data file: \"lmpdat\" - cif - cml Only the lammps data file and cif support reading from a file object, presently, due to the other formats depending on external library support. Args: f (Str or Path or File): either a path to a file or an open File to load from filetype (Str): filetype ('lmpdat', 'cif', or 'cml') of passed f File object, or explicit filetype to override default filetype implied from file extension. kwargs: keyword args passed on to individual load functions. \"\"\" fd = None path = None if isinstance ( f , io . TextIOBase ): fd = f if filetype is None : raise Exception ( \"If a File object is passed, a filetype must be passed with it\" ) else : # other cases are treated as either Pathlib path or strings path = f if filetype is None : _ , filetype = os . path . splitext ( path ) filetype = filetype [ 1 :] if filetype == \"lmpdat\" : with use_or_open ( fd , path ) as fh : atoms = cls . load_lmpdat ( fh , ** kwargs ) return atoms elif filetype == \"cml\" : if path is None : raise Exception ( \"Loading a cml file requires a path\" ) return cls . load_cml ( path , ** kwargs ) elif filetype == \"cif\" : with use_or_open ( fd , path ) as fh : return cls . load_cif ( fh , ** kwargs ) else : raise Exception ( \"Unsupported filetype\" ) load_cif ( f ) classmethod Loads a CIF file, including bonding information. Parameters: Name Type Description Default f File File-like object to read from. required Returns: Type Description Atoms loaded Atoms object Source code in mofun/atoms.py @classmethod def load_cif ( cls , f ): \"\"\"Loads a CIF file, including bonding information. Args: f (File): File-like object to read from. Returns: Atoms: loaded Atoms object \"\"\" def has_all_tags ( block , tags ): return np . array ([ block . has_key ( tag ) for tag in tags ]) . all () # PyCifRw supports file descriptors and path strings, but doesn't not support PathLib paths. if isinstance ( f , pathlib . PurePath ): f = str ( f ) cf = read_cif ( f ) block = cf [ cf . get_roots ()[ 0 ][ 0 ]] cart_coord_tags = [ \"_atom_site_Cartn_x\" , \"_atom_site_Cartn_y\" , \"_atom_site_Cartn_z\" , \"_atom_site_label\" ] fract_coord_tags = [ \"_atom_site_fract_x\" , \"_atom_site_fract_y\" , \"_atom_site_fract_z\" , \"_atom_site_label\" ] use_fract_coords = False if has_all_tags ( block , cart_coord_tags ): coords = [ block [ lbl ] for lbl in cart_coord_tags ] elif has_all_tags ( block , fract_coord_tags ): use_fract_coords = True coords = [ block [ lbl ] for lbl in fract_coord_tags ] else : raise ( \"no fractional or cartesian coords in CIF file\" ) x = [ float ( c ) for c in coords [ 0 ]] y = [ float ( c ) for c in coords [ 1 ]] z = [ float ( c ) for c in coords [ 2 ]] atom_name = coords [ 3 ] positions = np . array ([ x , y , z ], dtype = float ) . T atom_types = block [ '_atom_site_type_symbol' ] charges = [] if block . has_key ( '_atom_site_charge' ): charges = block [ '_atom_site_charge' ] bonds = [] bond_tags = [ \"_geom_bond_atom_site_label_1\" , \"_geom_bond_atom_site_label_2\" ] if has_all_tags ( block , bond_tags ): cifbonds = zip ( * [ block [ lbl ] for lbl in bond_tags ]) bonds = [( atom_name . index ( a ), atom_name . index ( b )) for ( a , b ) in cifbonds ] print ( \"WARNING: cif read doesn't handle bond types at present; bonding info is discarded. Use LAMMPS data file format if you need bonds\" ) bonds = [] cell = None cell_tags = [ '_cell_length_a' , '_cell_length_b' , '_cell_length_c' , '_cell_angle_alpha' , '_cell_angle_beta' , '_cell_angle_gamma' ] if has_all_tags ( block , cell_tags ): a , b , c , alpha , beta , gamma = [ float ( block [ tag ]) for tag in cell_tags ] if alpha != 90. or beta != 90 or gamma != 90. : raise Exception ( \"No support for non orthorhombic UCs at the moment!\" ) cell = np . identity ( 3 ) * ( a , b , c ) if use_fract_coords : positions *= ( a , b , c ) return cls ( elements = atom_types , positions = positions , cell = cell , charges = charges ) load_cml ( path ) classmethod Loads a CML file, including bonding information. Parameters: Name Type Description Default f File File-like object to read from. required Returns: Type Description Atoms loaded Atoms object Source code in mofun/atoms.py @classmethod def load_cml ( cls , path ): \"\"\"Loads a CML file, including bonding information. Args: f (File): File-like object to read from. Returns: Atoms: loaded Atoms object \"\"\" tree = ET . parse ( path ) root = tree . getroot () atom_dicts = [ a . attrib for a in root . findall ( './/atom' )] atom_tuples = [( a [ 'id' ], a [ 'elementType' ], float ( a [ 'x3' ]), float ( a [ 'y3' ]), float ( a [ 'z3' ])) for a in atom_dicts ] ids , elements , x , y , z = zip ( * atom_tuples ) id_to_idx = { id : i for i , id in enumerate ( ids )} positions = np . array ([ x , y , z ]) . T bond_dicts = [ a . attrib for a in root . findall ( './/bond' )] bond_tuples = [( a [ 'atomRefs2' ] . split (), float ( a [ 'order' ])) for a in bond_dicts ] bonds_by_ids , bond_orders = zip ( * bond_tuples ) bonds = [( id_to_idx [ b1 ], id_to_idx [ b2 ]) for ( b1 , b2 ) in bonds_by_ids ] bond_types = [ 0 for b in bonds ] return cls ( elements = elements , positions = positions , bonds = bonds , bond_types = bond_types ) load_lmpdat ( f , atom_format = 'full' , guess_atol = 0.1 ) classmethod Load Atoms object from lammps data file (.lmpdat) format. LAMMPS data files store only atom ids and masses, but do not store two other things we need: elements and atom type labels. These are the rules for inferring atom type labels and elements. In priority order, for elements, we: guess the elements using the masses by seeing if there is a periodic table element within 0.1 g/mol of the mass. If any atom types doe not match to an existing periodic table element, this method fails. use the atom ids as the elements (and print a warning). In priority order, for atom type labels, we: use the comments after each line in the Masses section as the atom type. If any line is missing a comment, this method fails. use the elements, if we have them. use the atom ids (and print a warning). Parameters: Name Type Description Default f File File-like object to read from. required atom_format str atom format of lammps data file. Currently supported atom formats are 'full' and 'atomic'. 'full' guess_atol float absolute tolerance a read mass can differ from a periodic table mass and still be considered that element. Default: 0.1. 0.1 Returns: Type Description Atoms loaded Atoms object Source code in mofun/atoms.py @classmethod def load_lmpdat ( cls , f , atom_format = \"full\" , guess_atol = 0.1 ): \"\"\"Load Atoms object from lammps data file (.lmpdat) format. LAMMPS data files store only atom ids and masses, but do not store two other things we need: elements and atom type labels. These are the rules for inferring atom type labels and elements. In priority order, for elements, we: 1. guess the elements using the masses by seeing if there is a periodic table element within 0.1 g/mol of the mass. If any atom types doe not match to an existing periodic table element, this method fails. 2. use the atom ids as the elements (and print a warning). In priority order, for atom type labels, we: 1. use the comments after each line in the Masses section as the atom type. If any line is missing a comment, this method fails. 2. use the elements, if we have them. 3. use the atom ids (and print a warning). Args: f (File): File-like object to read from. atom_format (str): atom format of lammps data file. Currently supported atom formats are 'full' and 'atomic'. guess_atol (float): absolute tolerance a read mass can differ from a periodic table mass and still be considered that element. Default: 0.1. Returns: Atoms: loaded Atoms object \"\"\" def get_types_tups ( arr ): types = tups = [] if len ( arr ) > 0 : types = arr [:, 1 ] - 1 tups = arr [:, 2 :] - 1 return types , tups masses = [] atoms = [] bonds = [] angles = [] dihedrals = [] impropers = [] pair_coeffs = [] bond_coeffs = [] angle_coeffs = [] dihedral_coeffs = [] improper_coeffs = [] atom_type_labels = [] atom_type_elements = [] cellx = celly = cellz = 0.0 sections_handled = [ \"Pair Coeffs\" , \"Bond Coeffs\" , \"Angle Coeffs\" , \"Dihedral Coeffs\" , \"Improper Coeffs\" , \"Atoms\" , \"Bonds\" , \"Angles\" , \"Dihedrals\" , \"Impropers\" , \"Masses\" ] current_section = None start_section = False for unprocessed_line in f : # handle comments comment_string = \"\" comment = None if \"#\" in unprocessed_line : line , comment = unprocessed_line . split ( '#' ) comment = comment . strip () comment_string = \" # \" + comment else : line = unprocessed_line . split ( '#' )[ 0 ] line = line . strip () if line in sections_handled : current_section = line start_section = True continue elif line == \"\" : if not start_section : # end of section or blank current_section = None start_section = False continue tup = line . split () if current_section == \"Masses\" : masses . append ( tup [ 1 ]) atom_type_labels . append ( comment ) elif current_section == \"Pair Coeffs\" : pair_coeffs . append ( \" %s%s \" % ( \" \" . join ( tup [ 1 :]), comment_string )) elif current_section == \"Bond Coeffs\" : bond_coeffs . append ( \" %s%s \" % ( \" \" . join ( tup [ 1 :]), comment_string )) elif current_section == \"Angle Coeffs\" : angle_coeffs . append ( \" %s%s \" % ( \" \" . join ( tup [ 1 :]), comment_string )) elif current_section == \"Dihedral Coeffs\" : dihedral_coeffs . append ( \" %s%s \" % ( \" \" . join ( tup [ 1 :]), comment_string )) elif current_section == \"Improper Coeffs\" : improper_coeffs . append ( \" %s%s \" % ( \" \" . join ( tup [ 1 :]), comment_string )) elif current_section == \"Atoms\" : atoms . append ( tup ) elif current_section == \"Bonds\" : bonds . append ( tup ) elif current_section == \"Angles\" : angles . append ( tup ) elif current_section == \"Dihedrals\" : dihedrals . append ( tup ) elif current_section == \"Impropers\" : impropers . append ( tup ) elif current_section is None : if \"xlo xhi\" in line : cellx = float ( tup [ 1 ]) - float ( tup [ 0 ]) elif \"ylo yhi\" in line : celly = float ( tup [ 1 ]) - float ( tup [ 0 ]) elif \"zlo zhi\" in line : cellz = float ( tup [ 1 ]) - float ( tup [ 0 ]) cell = None if cellx > 0. and celly > 0. and cellz > 0. : cell = np . identity ( 3 ) * ( cellx , celly , cellz ) atom_type_masses = np . array ( masses , dtype = float ) atoms = np . array ( atoms , dtype = float ) bonds = np . array ( bonds , dtype = int ) angles = np . array ( angles , dtype = int ) dihedrals = np . array ( dihedrals , dtype = int ) impropers = np . array ( impropers , dtype = int ) # note: bond indices in lmpdat file are 1-indexed and we are 0-indexed which is why # the bond pairs get a -1 if atom_format == \"atomic\" : atom_types = np . array ( atoms [:, 1 ] - 1 , dtype = int ) groups = np . zeros ( len ( atom_types )) charges = np . zeros ( len ( atom_types )) atom_tups = atoms [:, 2 : 5 ] elif atom_format == \"full\" : groups = np . array ( atoms [:, 1 ] - 1 , dtype = int ) atom_types = np . array ( atoms [:, 2 ] - 1 , dtype = int ) charges = np . array ( atoms [:, 3 ], dtype = float ) atom_tups = atoms [:, 4 : 7 ] # guess the atom elements; if this fails, use the atoms ids as the elements try : atom_type_elements = guess_elements_from_masses ( atom_type_masses , max_delta = guess_atol ) except Exception : print ( \"Warning: using type ids for elements since some masses do not correspond to periodic table elements within the set tolerance.\" ) atom_type_elements = [ str ( i + 1 ) for i in range ( len ( masses ))] # infer the atom type labels if ( atom_type_labels . count ( None ) == 0 ): # then loading atom types from the labels worked pass else : print ( \"Warning: using elements for atom type labels since there is not an atom type label comment for every atom type in the Masses section.\" ) atom_type_labels = atom_type_elements . copy () bond_types , bond_tups = get_types_tups ( bonds ) angle_types , angle_tups = get_types_tups ( angles ) dihedral_types , dihedral_tups = get_types_tups ( dihedrals ) improper_types , improper_tups = get_types_tups ( impropers ) return cls ( atom_types = atom_types , positions = atom_tups , charges = charges , atom_type_masses = atom_type_masses , atom_type_elements = atom_type_elements , bond_types = bond_types , bonds = bond_tups , angle_types = angle_types , angles = angle_tups , dihedral_types = dihedral_types , dihedrals = dihedral_tups , improper_types = improper_types , impropers = improper_tups , pair_coeffs = pair_coeffs , bond_type_coeffs = bond_coeffs , angle_type_coeffs = angle_coeffs , dihedral_type_coeffs = dihedral_coeffs , improper_type_coeffs = improper_coeffs , atom_type_labels = atom_type_labels , groups = groups , cell = cell ) replicate ( self , repldims = ( 1 , 1 , 1 )) Replicate atoms object across xyz dimensions Warnings: only works for orthorhombic at the moment! does not magically handle any bonds that may cross periodic boundary conditions! Parameters: Name Type Description Default repldims Tuple(int, int, int number of times to replicate in each dimension (1, 1, 1) Returns: Type Description Atoms replicated atoms. Source code in mofun/atoms.py def replicate ( self , repldims = ( 1 , 1 , 1 )): \"\"\"Replicate atoms object across xyz dimensions Warnings: * only works for orthorhombic at the moment! * does not magically handle any bonds that may cross periodic boundary conditions! Args: repldims (Tuple(int, int, int)): number of times to replicate in each dimension Returns: Atoms: replicated atoms. \"\"\" repl_atoms = self . copy () ucmults = np . array ( np . meshgrid ( * [ range ( r ) for r in repldims ])) . T . reshape ( - 1 , 3 ) ucmults = ucmults [ np . any ( ucmults != 0 , axis = 1 )] # remove [0,0,0] since in copy for ucmult in ucmults : transatoms = self . copy () transatoms . translate ( np . matmul ( transatoms . cell , ucmult )) repl_atoms . extend ( transatoms , offsets = ( 0 , 0 , 0 , 0 )) repl_atoms . cell = self . cell * repldims return repl_atoms save ( self , f , filetype = None , ** kwargs ) Saves an Atoms object to either a path or a file object and filetype. Can save any of the supported types: lammps data file: \"lmpdat\" mol Parameters: Name Type Description Default f Str or Path or File either a path to a file or an open File to save to required filetype Str filetype ('lmpdat', 'cif', or 'cml') of passed f File object, or explicit filetype to override default filetype implied from file extension. None kwargs keyword args passed on to individual save functions. {} Source code in mofun/atoms.py def save ( self , f , filetype = None , ** kwargs ): \"\"\"Saves an Atoms object to either a path or a file object and filetype. Can save any of the supported types: - lammps data file: \"lmpdat\" - mol Args: f (Str or Path or File): either a path to a file or an open File to save to filetype (Str): filetype ('lmpdat', 'cif', or 'cml') of passed f File object, or explicit filetype to override default filetype implied from file extension. kwargs: keyword args passed on to individual save functions. \"\"\" fd = None path = None if isinstance ( f , io . TextIOBase ): fd = f if filetype is None : raise Exception ( \"If a File object is passed, a filetype must be passed with it\" ) else : # other cases are treated as either Pathlib path or strings path = f if filetype is None : _ , filetype = os . path . splitext ( path ) filetype = filetype [ 1 :] if filetype == \"lmpdat\" : with use_or_open ( fd , path , mode = 'w' ) as fh : atoms = self . save_lmpdat ( fh , ** kwargs ) return atoms elif filetype == \"mol\" : with use_or_open ( fd , path , mode = 'w' ) as fh : return self . save_mol ( fh , ** kwargs ) else : raise Exception ( \"Unsupported filetype\" ) save_lmpdat ( self , f , atom_format = 'full' , file_comment = '' ) Saves a lmpdat file Parameters: Name Type Description Default f File an open file to write to required atom_format str LAMMPS atom format. Supports only 'atomic' and 'full'. 'full' file_comment str written in first line of output file. '' Source code in mofun/atoms.py def save_lmpdat ( self , f , atom_format = \"full\" , file_comment = \"\" ): \"\"\"Saves a lmpdat file Args: f (File): an open file to write to atom_format (str): LAMMPS atom format. Supports only 'atomic' and 'full'. file_comment (str): written in first line of output file. \"\"\" f . write ( \" %s (written by mofun) \\n\\n \" % file_comment ) f . write ( ' %d atoms \\n ' % len ( self . atom_types )) f . write ( ' %d bonds \\n ' % len ( self . bond_types )) f . write ( ' %d angles \\n ' % len ( self . angle_types )) f . write ( ' %d dihedrals \\n ' % len ( self . dihedral_types )) f . write ( ' %d impropers \\n ' % len ( self . improper_types )) f . write ( \" \\n \" ) if self . num_atom_types > 0 : f . write ( ' %d atom types \\n ' % self . num_atom_types ) if self . num_bond_types > 0 : f . write ( ' %d bond types \\n ' % self . num_bond_types ) if self . num_angle_types > 0 : f . write ( ' %d angle types \\n ' % self . num_angle_types ) if self . num_dihedral_types > 0 : f . write ( ' %d dihedral types \\n ' % self . num_dihedral_types ) if self . num_improper_types > 0 : f . write ( ' %d improper types \\n ' % self . num_improper_types ) if self . cell . shape == ( 3 , 3 ): xlohi , ylohi , zlohi = zip ([ 0 , 0 , 0 ], np . diag ( self . cell )) f . write ( \" %10.6f %10.6f xlo xhi \\n \" % xlohi ) f . write ( \" %10.6f %10.6f ylo yhi \\n \" % ylohi ) f . write ( \" %10.6f %10.6f zlo zhi \\n \" % zlohi ) f . write ( \" \\n Masses \\n\\n \" ) for i , m in enumerate ( self . atom_type_masses ): f . write ( \" %d %10.6f # %s \\n \" % ( i + 1 , m , self . label_atoms ( i ))) if len ( self . pair_coeffs ) > 0 : f . write ( ' \\n Pair Coeffs \\n\\n ' ) for i , coeffs in enumerate ( self . pair_coeffs ): f . write ( ' %d %s \\n ' % ( i + 1 , coeffs )) if len ( self . bond_type_coeffs ) > 0 : f . write ( ' \\n Bond Coeffs \\n\\n ' ) for i , coeffs in enumerate ( self . bond_type_coeffs ): f . write ( ' %d %s \\n ' % ( i + 1 , coeffs )) if len ( self . angle_type_coeffs ) > 0 : f . write ( ' \\n Angle Coeffs \\n\\n ' ) for i , coeffs in enumerate ( self . angle_type_coeffs ): f . write ( ' %d %s \\n ' % ( i + 1 , coeffs )) if len ( self . dihedral_type_coeffs ) > 0 : f . write ( ' \\n Dihedral Coeffs \\n\\n ' ) for i , coeffs in enumerate ( self . dihedral_type_coeffs ): f . write ( ' %d %s \\n ' % ( i + 1 , coeffs )) if len ( self . improper_type_coeffs ) > 0 : f . write ( ' \\n Improper Coeffs \\n\\n ' ) for i , coeffs in enumerate ( self . improper_type_coeffs ): f . write ( ' %d %s \\n ' % ( i + 1 , coeffs )) f . write ( \" \\n Atoms \\n\\n \" ) if atom_format == \"atomic\" : for i , ( x , y , z ) in enumerate ( self . positions ): f . write ( \" %d %d %10.6f %10.6f %10.6f # %s \\n \" % ( i + 1 , self . atom_types [ i ] + 1 , x , y , z , self . label_atoms ( self . atom_types [ i ]))) elif atom_format == \"full\" : for i , ( x , y , z ) in enumerate ( self . positions ): f . write ( \" %d %d %d %10.6f %10.6f %10.6f %10.6f # %s \\n \" % ( i + 1 , self . groups [ i ] + 1 , self . atom_types [ i ] + 1 , self . charges [ i ], x , y , z , self . label_atoms ( self . atom_types [ i ]))) if len ( self . bonds ) > 0 : f . write ( \" \\n Bonds \\n\\n \" ) for i , tup in enumerate ( self . bonds ): f . write ( \" %d %d %d %d # %s \\n \" % ( i + 1 , self . bond_types [ i ] + 1 , * ( np . array ( tup ) + 1 ), self . label_atoms ( tup , atom_indices = True ))) if len ( self . angles ) > 0 : f . write ( \" \\n Angles \\n\\n \" ) for i , tup in enumerate ( self . angles ): f . write ( \" %d %d %d %d %d # %s \\n \" % ( i + 1 , self . angle_types [ i ] + 1 , * ( np . array ( tup ) + 1 ), self . label_atoms ( tup , atom_indices = True ))) if len ( self . dihedrals ) > 0 : f . write ( \" \\n Dihedrals \\n\\n \" ) for i , tup in enumerate ( self . dihedrals ): f . write ( \" %d %d %d %d %d %d # %s \\n \" % ( i + 1 , self . dihedral_types [ i ] + 1 , * ( np . array ( tup ) + 1 ), self . label_atoms ( tup , atom_indices = True ))) if len ( self . impropers ) > 0 : f . write ( \" \\n Impropers \\n\\n \" ) for i , tup in enumerate ( self . impropers ): f . write ( \" %d %d %d %d %d %d # %s \\n \" % ( i + 1 , self . improper_types [ i ] + 1 , * ( np . array ( tup ) + 1 ), self . label_atoms ( tup , atom_indices = True ))) save_mol ( self , f , file_comment = '' ) Writes .mol file for structural information. Source code in mofun/atoms.py def save_mol ( self , f , file_comment = \"\" ): \"\"\"Writes .mol file for structural information.\"\"\" f . write ( \" Molecule_name: %s \\n \" % file_comment ) f . write ( \" \\n \" ) f . write ( \" Coord_Info: Listed Cartesian None \\n \" ) f . write ( \" %d \\n \" % len ( self )) for i , ( x , y , z ) in enumerate ( self . positions ): f . write ( \" %6d %10.4f %10.4f %10.4f %5s %10.8f 0 0 \\n \" % ( i + 1 , x , y , z , self . elements [ i ], self . charges [ i ])) f . write ( \" \\n\\n\\n \" ) f . write ( \" Fundcell_Info: Listed \\n \" ) f . write ( \" %10.4f %10.4f %10.4f \\n \" % tuple ( np . diag ( self . cell ))) f . write ( \" 90.0000 90.0000 90.0000 \\n \" ) f . write ( \" 0.00000 0.00000 0.00000 \\n \" ) f . write ( \" %10.4f %10.4f %10.4f \\n \" % tuple ( np . diag ( self . cell ))) to_ase ( self ) Convert to ASE atoms object. Only supports export of the positions and elements. Source code in mofun/atoms.py def to_ase ( self ): \"\"\"Convert to ASE atoms object. Only supports export of the positions and elements. \"\"\" kwargs = dict ( positions = self . positions ) if self . cell is not None and len ( self . cell ) > 0 : kwargs [ 'cell' ] = self . cell return ase . Atoms ( self . elements , ** kwargs ) find_unchanged_atom_pairs ( orig_structure , final_structure , max_delta = 1e-05 ) Returns array of tuple pairs, where each pair contains the indices in the original and the final structure that match. Does not work across PBCs. Source code in mofun/atoms.py def find_unchanged_atom_pairs ( orig_structure , final_structure , max_delta = 1e-5 ): \"\"\"Returns array of tuple pairs, where each pair contains the indices in the original and the final structure that match. Does not work across PBCs.\"\"\" match_pairs = [] for i , p1 in enumerate ( orig_structure . positions ): for j , p2 in enumerate ( final_structure . positions ): if norm ( np . array ( p2 ) - p1 ) < max_delta and orig_structure . elements [ i ] == final_structure . elements [ j ]: match_pairs . append (( i , j )) break return match_pairs","title":"Atoms"},{"location":"reference/atoms/#mofun.atoms.Atoms","text":"An Atoms object is a container for all the information required to keep track of a structure and the structure's force field. See the documentation on __init__ or load to see how to create an Atoms object. An Atoms object is made up primarily of numpy arrays and a couple normal lists. Some arrays are per-atom (one entry per atom): atom_types , positions , charges , and groups . Some arrays are per-atom-type (one entry per atom type): atom_type_masses , atom_type_elements , and atom_type_labels . Some arrays are per-bond (one entry per bond): bonds , and bond_types . Some arrays are per-angle (one entry per angle): angles , and angle_types . Some arrays are per-dihedral (one entry per dihedral): dihedrals , and dihedral_types . Some arrays are per-improper (one entry per improper): impropers , and improper_types . Atoms also stores information on the coefficients needed to define each force field term: pair_coeffs , bond_type_coeffs , angle_type_coeffs , dihedral_type_coeffs , and improper_type_coeffs . The *_coeffs variables are lists of strings, where the item index corresponds to the *_type, and the string is the full LAMMPS coeffs definition string. we do not interpret any of the LAMMPS coefficient specifics, we just store it in its original form, i.e. this Angle Coeffs section: Angle Coeffs 1 cosine/periodic 72.500283 -1 1 # C_R O_1 H_ 2 cosine/periodic 277.164705 -1 3 # C_R C_R O_1 would be interpreted like this: angle_type_coeffs= [\"cosine/periodic 72.500283 -1 1 # C_R O_1 H_\", \"cosine/periodic 277.164705 -1 3 # C_R C_R O_1\"]","title":"Atoms"},{"location":"reference/atoms/#mofun.atoms.Atoms.__init__","text":"Create an Atoms object. An Atoms object can be created without any atoms using Atoms() . For creating more interesting Atoms objects, there are a few rules to keep in mind. The parameters atom_types , positions , charges , and groups are all lists that should have a size equal to the number of atoms in the system. positions is mandatory; charges , and groups are optional (both default to 0 for each atom) and there are two ways to specify atom types: 1) specify the atom_types and atom_type_elements explicitly, which is how the load_lmpdat method loads Atoms objects from a LAMMPS data file, or 2) specify per-atom elements and and have MOFUN auto-number the atom types for you, which is more convenient when specifying small molecules in code or when loading from other file formats such as CML or CIF which may store element information but not type information. When explicitly setting the types, you must pass atom_types and atom_type_elements . atom_types is a list of int type ids >= 0, one for each atom in the system. atom_type_elements is a list of element names (e.g. \"C\", \"N\", \"Zr\") per atom type . For example, if your system is propane, your atom_types list could be [0, 1, 1, 1] and your atom_type_elements list would then be [\"C\", \"H\"]. To specify per-atom elements, you must pass elements with either a list of elements, such as Atoms(elements=[\"C\", \"C\"], ...) or with a string Atoms(elements=\"CC\", ...) . If you use the elements parameter, then type ids are automatically generated. Passing atom_type_masses is optional, and masses will be inferred from the elements if missing. If you are using atom types with masses that do not correspond to periodic table elements, then you will need to specify the masses explicitly. Passing force field term information for bonds , angles , dihedrals , and impropers is optional, as well as passing force field coefficients for LAMMPS with pair_coeffs , bond_type_coeffs , angle_type_coeffs , dihedral_type_coeffs , and improper_type_coeffs . Examples: a = Atoms() # create an empty Atoms object with no atoms a = Atoms(atom_types=[0], positions=[[0,0,0]]) # create one atom of type 0 a = Atoms(elements=[\"C\"], positions=[[0,0,0]]) # create one Carbon a = Atoms(elements=[\"C\", \"C\"], positions=[[0,0,0], [1,0,0]]) # create two Carbons a = Atoms(elements=\"CC\", positions=[[0,0,0], [1,0,0]]) # create two Carbons using shorthand element notation Parameters: Name Type Description Default atom_types List[int] list of integer type ids, one per atom. [] positions List[Tuple[float, float, float]] list of tuple atom x,y,z coordinates, one per atom. [] charges List[float] list of charges, one per atom. Defaults to 0 for each atom if not passed. [] groups List[int] list of integer groups, one per atom. For LAMMPS this gets mapped to a \"molecule id\". Defaults to 0 for each atom if not passed. [] elements List[str], str either a list of elements, (e.g. [\"C\", \"H\", \"H\", \"H\"]) or an element string (e.g. \"CHHH\") [] atom_type_masses List[float] list of atom type masses, one per atom type. If masses are not passed, they will be inferred from the atom_type_elements . [] atom_type_elements List[str] list of atom type elements, one per atom type. [] atom_type_labels List[str] list of atom type labels, one per atom type. Used in LAMMPS data file line comments as type labels. [] bonds List[Tuple[int, int]] list of bond tuples where each tuple defines a pair of atoms that are bonded. Each value in the tuple is an index of an atom in the atom_* lists. [] bond_types List[int] list of bond type id ints for each bond defined in bonds . [] angles List[Tuple[int, int, int]] list of angle tuples where each tuple defines a triplet of atoms making up the angle. Each value in the tuple is an index of an atom in the atom_* lists. [] angle_types List[int] list of angle type id ints for each angle defined in angles . [] dihedrals List[Tuple[int, int, int, int]] list of dihedral tuples where each dihedral defines a quartet of atoms making up the dihedral. Each value in the tuple is an index of an atom in the atom_* lists. [] dihedral_types List[int] list of dihedral type id ints for each dihedral defined in dihedrals . [] impropers List[Tuple[int, int, int, int]] list of improper tuples where each improper defines a quartet of atoms making up the improper. Each value in the tuple is an index of an atom in the atom_* lists. [] improper_types List[int] list of improper type id ints for each improper defined in impropers . [] pair_coeffs List[str] pair coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per atom type. [] bond_type_coeffs List[str] bond coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per bond type. [] angle_type_coeffs List[str] angle coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per angle type. [] dihedral_type_coeffs List[str] dihedral coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per dihedral type. [] improper_type_coeffs List[str] improper coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per improper type. [] cell Array(3x3 3x3 array of unit cell vectors. [] Returns: Type Description Atoms the atoms object. Source code in mofun/atoms.py def __init__ ( self , atom_types = [], positions = [], charges = [], groups = [], elements = [], atom_type_masses = [], atom_type_elements = [], atom_type_labels = [], bonds = [], bond_types = [], angles = [], angle_types = [], dihedrals = [], dihedral_types = [], impropers = [], improper_types = [], pair_coeffs = [], bond_type_coeffs = [], angle_type_coeffs = [], dihedral_type_coeffs = [], improper_type_coeffs = [], cell = []): \"\"\"Create an Atoms object. An Atoms object can be created without any atoms using `Atoms()`. For creating more interesting Atoms objects, there are a few rules to keep in mind. The parameters `atom_types`, `positions`, `charges`, and `groups` are all lists that should have a size equal to the number of atoms in the system. `positions` is mandatory; `charges`, and `groups` are optional (both default to 0 for each atom) and there are two ways to specify atom types: 1) specify the atom_types and atom_type_elements explicitly, which is how the `load_lmpdat` method loads Atoms objects from a LAMMPS data file, or 2) specify per-atom elements and and have MOFUN auto-number the atom types for you, which is more convenient when specifying small molecules in code or when loading from other file formats such as CML or CIF which may store element information but not type information. When explicitly setting the types, you must pass `atom_types` and `atom_type_elements`. `atom_types` is a list of int type ids >= 0, one for each atom in the system. `atom_type_elements` is a list of element names (e.g. \"C\", \"N\", \"Zr\") per _atom type_. For example, if your system is propane, your atom_types list could be [0, 1, 1, 1] and your atom_type_elements list would then be [\"C\", \"H\"]. To specify per-atom elements, you must pass `elements` with either a list of elements, such as `Atoms(elements=[\"C\", \"C\"], ...)` or with a string `Atoms(elements=\"CC\", ...)`. If you use the `elements` parameter, then type ids are automatically generated. Passing `atom_type_masses` is optional, and masses will be inferred from the elements if missing. If you are using atom types with masses that do not correspond to periodic table elements, then you will need to specify the masses explicitly. Passing force field term information for `bonds`, `angles`, `dihedrals`, and `impropers` is optional, as well as passing force field coefficients for LAMMPS with `pair_coeffs`, `bond_type_coeffs`, `angle_type_coeffs`, `dihedral_type_coeffs`, and `improper_type_coeffs`. Examples: ``` a = Atoms() # create an empty Atoms object with no atoms a = Atoms(atom_types=[0], positions=[[0,0,0]]) # create one atom of type 0 a = Atoms(elements=[\"C\"], positions=[[0,0,0]]) # create one Carbon a = Atoms(elements=[\"C\", \"C\"], positions=[[0,0,0], [1,0,0]]) # create two Carbons a = Atoms(elements=\"CC\", positions=[[0,0,0], [1,0,0]]) # create two Carbons using shorthand element notation ``` Args: atom_types (List[int]): list of integer type ids, one per atom. positions (List[Tuple[float, float, float]]): list of tuple atom x,y,z coordinates, one per atom. charges (List[float]): list of charges, one per atom. Defaults to 0 for each atom if not passed. groups (List[int]): list of integer groups, one per atom. For LAMMPS this gets mapped to a \"molecule id\". Defaults to 0 for each atom if not passed. elements (List[str], str): either a list of elements, (e.g. [\"C\", \"H\", \"H\", \"H\"]) or an element string (e.g. \"CHHH\") atom_type_masses (List[float]): list of atom type masses, one per atom type. If masses are not passed, they will be inferred from the `atom_type_elements`. atom_type_elements (List[str]): list of atom type elements, one per atom type. atom_type_labels (List[str]): list of atom type labels, one per atom type. Used in LAMMPS data file line comments as type labels. bonds (List[Tuple[int, int]]): list of bond tuples where each tuple defines a pair of atoms that are bonded. Each value in the tuple is an index of an atom in the atom_* lists. bond_types (List[int]): list of bond type id ints for each bond defined in `bonds`. angles (List[Tuple[int, int, int]]): list of angle tuples where each tuple defines a triplet of atoms making up the angle. Each value in the tuple is an index of an atom in the atom_* lists. angle_types (List[int]): list of angle type id ints for each angle defined in `angles`. dihedrals (List[Tuple[int, int, int, int]]): list of dihedral tuples where each dihedral defines a quartet of atoms making up the dihedral. Each value in the tuple is an index of an atom in the atom_* lists. dihedral_types (List[int]): list of dihedral type id ints for each dihedral defined in `dihedrals`. impropers (List[Tuple[int, int, int, int]]): list of improper tuples where each improper defines a quartet of atoms making up the improper. Each value in the tuple is an index of an atom in the atom_* lists. improper_types (List[int]): list of improper type id ints for each improper defined in `impropers`. pair_coeffs (List[str]): pair coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per atom type. bond_type_coeffs (List[str]): bond coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per bond type. angle_type_coeffs (List[str]): angle coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per angle type. dihedral_type_coeffs (List[str]): dihedral coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per dihedral type. improper_type_coeffs (List[str]): improper coefficients definition string (anything supported by LAMMPS in a data file but without the type id). One per improper type. cell (Array(3x3)): 3x3 array of unit cell vectors. Returns: Atoms: the atoms object. \"\"\" self . atom_type_masses = np . array ( atom_type_masses , ndmin = 1 ) self . positions = np . array ( positions , dtype = float , ndmin = 1 ) self . cell = np . array ( cell ) self . bonds = np . array ( bonds , dtype = int ) self . bond_types = np . array ( bond_types , dtype = int ) self . angles = np . array ( angles , dtype = int ) self . angle_types = np . array ( angle_types , dtype = int ) self . dihedrals = np . array ( dihedrals , dtype = int ) self . dihedral_types = np . array ( dihedral_types , dtype = int ) self . impropers = np . array ( impropers , dtype = int ) self . improper_types = np . array ( improper_types , dtype = int ) self . pair_coeffs = np . array ( pair_coeffs ) self . bond_type_coeffs = np . array ( bond_type_coeffs ) self . angle_type_coeffs = np . array ( angle_type_coeffs ) self . dihedral_type_coeffs = np . array ( dihedral_type_coeffs ) self . improper_type_coeffs = np . array ( improper_type_coeffs ) if len ( charges ) > 0 : self . charges = np . array ( charges , dtype = float ) else : self . charges = np . zeros ( len ( self . positions ), dtype = float ) if len ( groups ) > 0 : self . groups = np . array ( groups , dtype = int ) else : self . groups = np . zeros ( len ( self . positions ), dtype = int ) # load atom_types and atom_type_elements if len ( atom_types ) > 0 : # default case or a __getitem__ subset self . atom_types = np . array ( atom_types ) self . atom_type_elements = atom_type_elements elif len ( elements ) > 0 : # from element array, such as from ASE atoms or read CML # i.e. Propane ['C', 'H', 'H', 'H', 'C', 'H', 'H', 'C', 'H', 'H', 'H']: # or from element string, i.e. Propane \"CHHHCHHCHHH\" (shorthand): if isinstance ( elements , str ): elements = list ( Formula ( elements )) # preserve order of types self . atom_type_elements = list ( dict . fromkeys ( elements ) . keys ()) self . atom_types = np . array ([ self . atom_type_elements . index ( s ) for s in elements ]) else : # no atom_type_elements or elements passed # this should be the `Atoms()` case; if not, it will fail the asserts below self . atom_types = np . array ([], ndmin = 1 ) self . atom_type_elements = [] # automatically determine masses from elements if masses are not passed if len ( self . atom_type_masses ) == 0 and len ( self . atom_type_elements ) > 0 : self . atom_type_masses = [ ATOMIC_MASSES [ s ] for s in self . atom_type_elements ] if len ( atom_type_labels ) > 0 : self . atom_type_labels = atom_type_labels else : print ( \"WARNING: using the atom elements as the atom_type_labels since labels were not supplied.\" ) # use default atom types equal to the element; this may not be unique! self . atom_type_labels = self . atom_type_elements self . assert_arrays_are_consistent_sizes ()","title":"__init__()"},{"location":"reference/atoms/#mofun.atoms.Atoms.extend","text":"Adds other Atoms object's arrays to its own. The default behavior is for all the types and params from other structure to be appended to this structure. Alternatively, an offsets tuple may be passed with the results of calling extend_types(). No new types will be added, but the newly added atoms, bonds, etc will refer to types by their value in the other Atoms object plus the offset. Use this when you are adding the same set of atoms multiple times, or if your other atoms already share the same type ids as this object. For the later case, the tuple (0,0,0,0) may be passed in. Parameters: Name Type Description Default other Atoms atoms to add to self required offsets an offsets tuple with the results of calling extend_types(). None structure_index_map dictionary where key is an index in other and value is an index in self, where entries only exist if the position and element of the entries are identical and can be considered to be the same atom. {} verbose bool print debugging info. False Source code in mofun/atoms.py def extend ( self , other , offsets = None , structure_index_map = {}, verbose = False ): \"\"\"Adds other Atoms object's arrays to its own. The default behavior is for all the types and params from other structure to be appended to this structure. Alternatively, an offsets tuple may be passed with the results of calling extend_types(). No new types will be added, but the newly added atoms, bonds, etc will refer to types by their value in the other Atoms object plus the offset. Use this when you are adding the same set of atoms multiple times, or if your other atoms already share the same type ids as this object. For the later case, the tuple (0,0,0,0) may be passed in. Args: other (Atoms): atoms to add to self offsets: an offsets tuple with the results of calling extend_types(). structure_index_map: dictionary where key is an index in other and value is an index in self, where entries only exist if the position and element of the entries are identical and can be considered to be the same atom. verbose (bool): print debugging info. \"\"\" atom_idx_offset = len ( self . positions ) if offsets is None : if verbose : print ( \"auto offset: extending types\" ) offsets = self . extend_types ( other ) # update atom types for atoms that are already part of self Atoms object for other_index , self_index in structure_index_map . items (): self . atom_types [ self_index ] = other . atom_types [ other_index ] + offsets [ 0 ] # add atoms that are not part of self Atoms object atoms_to_add = [ i for i in range ( len ( other )) if i not in structure_index_map . keys ()] self . positions = np . append ( self . positions , other . positions [ atoms_to_add ], axis = 0 ) self . atom_types = np . append ( self . atom_types , other . atom_types [ atoms_to_add ] + offsets [ 0 ]) self . charges = np . append ( self . charges , other . charges [ atoms_to_add ]) self . groups = np . append ( self . groups , other . groups [ atoms_to_add ]) # update structure index map structure_index_map2 = { a : i + atom_idx_offset for i , a in enumerate ( atoms_to_add )} structure_index_map2 . update ( structure_index_map ) convert2structureindex = np . vectorize ( structure_index_map2 . get ) def find_existing_topo ( topo , new_topo ): \"\"\" find existing topo tuples between the same atoms as a new topo set. Used to allow an override of an existing force field term by finding old terms between the same atoms to delete\"\"\" existing_topo = [ tuple ( x ) for x in topo ] new_topo_tuples = [ tuple ( x ) for x in new_topo ] existing_topo_indices = [ existing_topo . index ( b ) for b in new_topo_tuples if b in existing_topo ] return existing_topo_indices if len ( other . bonds ) > 0 : new_bonds = convert2structureindex ( other . bonds ) existing_bond_indices = find_existing_topo ( self . bonds , new_bonds ) self . bonds = np . append ( self . bonds , new_bonds ) . reshape (( - 1 , 2 )) self . bond_types = np . append ( self . bond_types , other . bond_types + offsets [ 1 ]) self . bonds = np . delete ( self . bonds , existing_bond_indices , axis = 0 ) self . bond_types = np . delete ( self . bond_types , existing_bond_indices ) if len ( other . angles ) > 0 : new_angles = convert2structureindex ( other . angles ) existing_angle_indices = find_existing_topo ( self . angles , new_angles ) self . angles = np . append ( self . angles , new_angles ) . reshape (( - 1 , 3 )) self . angle_types = np . append ( self . angle_types , other . angle_types + offsets [ 2 ]) self . angles = np . delete ( self . angles , existing_angle_indices , axis = 0 ) self . angle_types = np . delete ( self . angle_types , existing_angle_indices ) if len ( other . dihedrals ) > 0 : new_dihedrals = convert2structureindex ( other . dihedrals ) existing_dihedral_indices = find_existing_topo ( self . dihedrals , new_dihedrals ) self . dihedrals = np . append ( self . dihedrals , new_dihedrals ) . reshape (( - 1 , 4 )) self . dihedral_types = np . append ( self . dihedral_types , other . dihedral_types + offsets [ 3 ]) self . dihedrals = np . delete ( self . dihedrals , existing_dihedral_indices , axis = 0 ) self . dihedral_types = np . delete ( self . dihedral_types , existing_dihedral_indices ) if len ( other . impropers ) > 0 : new_impropers = convert2structureindex ( other . impropers ) existing_improper_indices = find_existing_topo ( self . impropers , new_impropers ) self . impropers = np . append ( self . impropers , new_impropers ) . reshape (( - 1 , 4 )) self . improper_types = np . append ( self . improper_types , other . improper_types + offsets [ 4 ]) self . impropers = np . delete ( self . impropers , existing_improper_indices , axis = 0 ) self . improper_types = np . delete ( self . improper_types , existing_improper_indices ) self . assert_arrays_are_consistent_sizes ()","title":"extend()"},{"location":"reference/atoms/#mofun.atoms.Atoms.from_ase_atoms","text":"Create an Atoms object from an ASE Atoms object. Only supports importing the atom positions, elements, and the unit cell. Parameters: Name Type Description Default atoms ASE Atoms object atoms to load from required Returns: Type Description Atoms atoms loaded from an ASE Atoms object. Source code in mofun/atoms.py @classmethod def from_ase_atoms ( cls , atoms ): \"\"\"Create an Atoms object from an ASE Atoms object. Only supports importing the atom positions, elements, and the unit cell. Args: atoms (ASE Atoms object): atoms to load from Returns: Atoms: atoms loaded from an ASE Atoms object. \"\"\" return cls ( elements = atoms . symbols , positions = atoms . positions , cell = atoms . cell )","title":"from_ase_atoms()"},{"location":"reference/atoms/#mofun.atoms.Atoms.load","text":"Creates an Atoms object from either a path or a file object and filetype. Can load any of the supported types: lammps data file: \"lmpdat\" cif cml Only the lammps data file and cif support reading from a file object, presently, due to the other formats depending on external library support. Parameters: Name Type Description Default f Str or Path or File either a path to a file or an open File to load from required filetype Str filetype ('lmpdat', 'cif', or 'cml') of passed f File object, or explicit filetype to override default filetype implied from file extension. None kwargs keyword args passed on to individual load functions. {} Source code in mofun/atoms.py @classmethod def load ( cls , f , filetype = None , ** kwargs ): \"\"\"Creates an Atoms object from either a path or a file object and filetype. Can load any of the supported types: - lammps data file: \"lmpdat\" - cif - cml Only the lammps data file and cif support reading from a file object, presently, due to the other formats depending on external library support. Args: f (Str or Path or File): either a path to a file or an open File to load from filetype (Str): filetype ('lmpdat', 'cif', or 'cml') of passed f File object, or explicit filetype to override default filetype implied from file extension. kwargs: keyword args passed on to individual load functions. \"\"\" fd = None path = None if isinstance ( f , io . TextIOBase ): fd = f if filetype is None : raise Exception ( \"If a File object is passed, a filetype must be passed with it\" ) else : # other cases are treated as either Pathlib path or strings path = f if filetype is None : _ , filetype = os . path . splitext ( path ) filetype = filetype [ 1 :] if filetype == \"lmpdat\" : with use_or_open ( fd , path ) as fh : atoms = cls . load_lmpdat ( fh , ** kwargs ) return atoms elif filetype == \"cml\" : if path is None : raise Exception ( \"Loading a cml file requires a path\" ) return cls . load_cml ( path , ** kwargs ) elif filetype == \"cif\" : with use_or_open ( fd , path ) as fh : return cls . load_cif ( fh , ** kwargs ) else : raise Exception ( \"Unsupported filetype\" )","title":"load()"},{"location":"reference/atoms/#mofun.atoms.Atoms.load_cif","text":"Loads a CIF file, including bonding information. Parameters: Name Type Description Default f File File-like object to read from. required Returns: Type Description Atoms loaded Atoms object Source code in mofun/atoms.py @classmethod def load_cif ( cls , f ): \"\"\"Loads a CIF file, including bonding information. Args: f (File): File-like object to read from. Returns: Atoms: loaded Atoms object \"\"\" def has_all_tags ( block , tags ): return np . array ([ block . has_key ( tag ) for tag in tags ]) . all () # PyCifRw supports file descriptors and path strings, but doesn't not support PathLib paths. if isinstance ( f , pathlib . PurePath ): f = str ( f ) cf = read_cif ( f ) block = cf [ cf . get_roots ()[ 0 ][ 0 ]] cart_coord_tags = [ \"_atom_site_Cartn_x\" , \"_atom_site_Cartn_y\" , \"_atom_site_Cartn_z\" , \"_atom_site_label\" ] fract_coord_tags = [ \"_atom_site_fract_x\" , \"_atom_site_fract_y\" , \"_atom_site_fract_z\" , \"_atom_site_label\" ] use_fract_coords = False if has_all_tags ( block , cart_coord_tags ): coords = [ block [ lbl ] for lbl in cart_coord_tags ] elif has_all_tags ( block , fract_coord_tags ): use_fract_coords = True coords = [ block [ lbl ] for lbl in fract_coord_tags ] else : raise ( \"no fractional or cartesian coords in CIF file\" ) x = [ float ( c ) for c in coords [ 0 ]] y = [ float ( c ) for c in coords [ 1 ]] z = [ float ( c ) for c in coords [ 2 ]] atom_name = coords [ 3 ] positions = np . array ([ x , y , z ], dtype = float ) . T atom_types = block [ '_atom_site_type_symbol' ] charges = [] if block . has_key ( '_atom_site_charge' ): charges = block [ '_atom_site_charge' ] bonds = [] bond_tags = [ \"_geom_bond_atom_site_label_1\" , \"_geom_bond_atom_site_label_2\" ] if has_all_tags ( block , bond_tags ): cifbonds = zip ( * [ block [ lbl ] for lbl in bond_tags ]) bonds = [( atom_name . index ( a ), atom_name . index ( b )) for ( a , b ) in cifbonds ] print ( \"WARNING: cif read doesn't handle bond types at present; bonding info is discarded. Use LAMMPS data file format if you need bonds\" ) bonds = [] cell = None cell_tags = [ '_cell_length_a' , '_cell_length_b' , '_cell_length_c' , '_cell_angle_alpha' , '_cell_angle_beta' , '_cell_angle_gamma' ] if has_all_tags ( block , cell_tags ): a , b , c , alpha , beta , gamma = [ float ( block [ tag ]) for tag in cell_tags ] if alpha != 90. or beta != 90 or gamma != 90. : raise Exception ( \"No support for non orthorhombic UCs at the moment!\" ) cell = np . identity ( 3 ) * ( a , b , c ) if use_fract_coords : positions *= ( a , b , c ) return cls ( elements = atom_types , positions = positions , cell = cell , charges = charges )","title":"load_cif()"},{"location":"reference/atoms/#mofun.atoms.Atoms.load_cml","text":"Loads a CML file, including bonding information. Parameters: Name Type Description Default f File File-like object to read from. required Returns: Type Description Atoms loaded Atoms object Source code in mofun/atoms.py @classmethod def load_cml ( cls , path ): \"\"\"Loads a CML file, including bonding information. Args: f (File): File-like object to read from. Returns: Atoms: loaded Atoms object \"\"\" tree = ET . parse ( path ) root = tree . getroot () atom_dicts = [ a . attrib for a in root . findall ( './/atom' )] atom_tuples = [( a [ 'id' ], a [ 'elementType' ], float ( a [ 'x3' ]), float ( a [ 'y3' ]), float ( a [ 'z3' ])) for a in atom_dicts ] ids , elements , x , y , z = zip ( * atom_tuples ) id_to_idx = { id : i for i , id in enumerate ( ids )} positions = np . array ([ x , y , z ]) . T bond_dicts = [ a . attrib for a in root . findall ( './/bond' )] bond_tuples = [( a [ 'atomRefs2' ] . split (), float ( a [ 'order' ])) for a in bond_dicts ] bonds_by_ids , bond_orders = zip ( * bond_tuples ) bonds = [( id_to_idx [ b1 ], id_to_idx [ b2 ]) for ( b1 , b2 ) in bonds_by_ids ] bond_types = [ 0 for b in bonds ] return cls ( elements = elements , positions = positions , bonds = bonds , bond_types = bond_types )","title":"load_cml()"},{"location":"reference/atoms/#mofun.atoms.Atoms.load_lmpdat","text":"Load Atoms object from lammps data file (.lmpdat) format. LAMMPS data files store only atom ids and masses, but do not store two other things we need: elements and atom type labels. These are the rules for inferring atom type labels and elements. In priority order, for elements, we: guess the elements using the masses by seeing if there is a periodic table element within 0.1 g/mol of the mass. If any atom types doe not match to an existing periodic table element, this method fails. use the atom ids as the elements (and print a warning). In priority order, for atom type labels, we: use the comments after each line in the Masses section as the atom type. If any line is missing a comment, this method fails. use the elements, if we have them. use the atom ids (and print a warning). Parameters: Name Type Description Default f File File-like object to read from. required atom_format str atom format of lammps data file. Currently supported atom formats are 'full' and 'atomic'. 'full' guess_atol float absolute tolerance a read mass can differ from a periodic table mass and still be considered that element. Default: 0.1. 0.1 Returns: Type Description Atoms loaded Atoms object Source code in mofun/atoms.py @classmethod def load_lmpdat ( cls , f , atom_format = \"full\" , guess_atol = 0.1 ): \"\"\"Load Atoms object from lammps data file (.lmpdat) format. LAMMPS data files store only atom ids and masses, but do not store two other things we need: elements and atom type labels. These are the rules for inferring atom type labels and elements. In priority order, for elements, we: 1. guess the elements using the masses by seeing if there is a periodic table element within 0.1 g/mol of the mass. If any atom types doe not match to an existing periodic table element, this method fails. 2. use the atom ids as the elements (and print a warning). In priority order, for atom type labels, we: 1. use the comments after each line in the Masses section as the atom type. If any line is missing a comment, this method fails. 2. use the elements, if we have them. 3. use the atom ids (and print a warning). Args: f (File): File-like object to read from. atom_format (str): atom format of lammps data file. Currently supported atom formats are 'full' and 'atomic'. guess_atol (float): absolute tolerance a read mass can differ from a periodic table mass and still be considered that element. Default: 0.1. Returns: Atoms: loaded Atoms object \"\"\" def get_types_tups ( arr ): types = tups = [] if len ( arr ) > 0 : types = arr [:, 1 ] - 1 tups = arr [:, 2 :] - 1 return types , tups masses = [] atoms = [] bonds = [] angles = [] dihedrals = [] impropers = [] pair_coeffs = [] bond_coeffs = [] angle_coeffs = [] dihedral_coeffs = [] improper_coeffs = [] atom_type_labels = [] atom_type_elements = [] cellx = celly = cellz = 0.0 sections_handled = [ \"Pair Coeffs\" , \"Bond Coeffs\" , \"Angle Coeffs\" , \"Dihedral Coeffs\" , \"Improper Coeffs\" , \"Atoms\" , \"Bonds\" , \"Angles\" , \"Dihedrals\" , \"Impropers\" , \"Masses\" ] current_section = None start_section = False for unprocessed_line in f : # handle comments comment_string = \"\" comment = None if \"#\" in unprocessed_line : line , comment = unprocessed_line . split ( '#' ) comment = comment . strip () comment_string = \" # \" + comment else : line = unprocessed_line . split ( '#' )[ 0 ] line = line . strip () if line in sections_handled : current_section = line start_section = True continue elif line == \"\" : if not start_section : # end of section or blank current_section = None start_section = False continue tup = line . split () if current_section == \"Masses\" : masses . append ( tup [ 1 ]) atom_type_labels . append ( comment ) elif current_section == \"Pair Coeffs\" : pair_coeffs . append ( \" %s%s \" % ( \" \" . join ( tup [ 1 :]), comment_string )) elif current_section == \"Bond Coeffs\" : bond_coeffs . append ( \" %s%s \" % ( \" \" . join ( tup [ 1 :]), comment_string )) elif current_section == \"Angle Coeffs\" : angle_coeffs . append ( \" %s%s \" % ( \" \" . join ( tup [ 1 :]), comment_string )) elif current_section == \"Dihedral Coeffs\" : dihedral_coeffs . append ( \" %s%s \" % ( \" \" . join ( tup [ 1 :]), comment_string )) elif current_section == \"Improper Coeffs\" : improper_coeffs . append ( \" %s%s \" % ( \" \" . join ( tup [ 1 :]), comment_string )) elif current_section == \"Atoms\" : atoms . append ( tup ) elif current_section == \"Bonds\" : bonds . append ( tup ) elif current_section == \"Angles\" : angles . append ( tup ) elif current_section == \"Dihedrals\" : dihedrals . append ( tup ) elif current_section == \"Impropers\" : impropers . append ( tup ) elif current_section is None : if \"xlo xhi\" in line : cellx = float ( tup [ 1 ]) - float ( tup [ 0 ]) elif \"ylo yhi\" in line : celly = float ( tup [ 1 ]) - float ( tup [ 0 ]) elif \"zlo zhi\" in line : cellz = float ( tup [ 1 ]) - float ( tup [ 0 ]) cell = None if cellx > 0. and celly > 0. and cellz > 0. : cell = np . identity ( 3 ) * ( cellx , celly , cellz ) atom_type_masses = np . array ( masses , dtype = float ) atoms = np . array ( atoms , dtype = float ) bonds = np . array ( bonds , dtype = int ) angles = np . array ( angles , dtype = int ) dihedrals = np . array ( dihedrals , dtype = int ) impropers = np . array ( impropers , dtype = int ) # note: bond indices in lmpdat file are 1-indexed and we are 0-indexed which is why # the bond pairs get a -1 if atom_format == \"atomic\" : atom_types = np . array ( atoms [:, 1 ] - 1 , dtype = int ) groups = np . zeros ( len ( atom_types )) charges = np . zeros ( len ( atom_types )) atom_tups = atoms [:, 2 : 5 ] elif atom_format == \"full\" : groups = np . array ( atoms [:, 1 ] - 1 , dtype = int ) atom_types = np . array ( atoms [:, 2 ] - 1 , dtype = int ) charges = np . array ( atoms [:, 3 ], dtype = float ) atom_tups = atoms [:, 4 : 7 ] # guess the atom elements; if this fails, use the atoms ids as the elements try : atom_type_elements = guess_elements_from_masses ( atom_type_masses , max_delta = guess_atol ) except Exception : print ( \"Warning: using type ids for elements since some masses do not correspond to periodic table elements within the set tolerance.\" ) atom_type_elements = [ str ( i + 1 ) for i in range ( len ( masses ))] # infer the atom type labels if ( atom_type_labels . count ( None ) == 0 ): # then loading atom types from the labels worked pass else : print ( \"Warning: using elements for atom type labels since there is not an atom type label comment for every atom type in the Masses section.\" ) atom_type_labels = atom_type_elements . copy () bond_types , bond_tups = get_types_tups ( bonds ) angle_types , angle_tups = get_types_tups ( angles ) dihedral_types , dihedral_tups = get_types_tups ( dihedrals ) improper_types , improper_tups = get_types_tups ( impropers ) return cls ( atom_types = atom_types , positions = atom_tups , charges = charges , atom_type_masses = atom_type_masses , atom_type_elements = atom_type_elements , bond_types = bond_types , bonds = bond_tups , angle_types = angle_types , angles = angle_tups , dihedral_types = dihedral_types , dihedrals = dihedral_tups , improper_types = improper_types , impropers = improper_tups , pair_coeffs = pair_coeffs , bond_type_coeffs = bond_coeffs , angle_type_coeffs = angle_coeffs , dihedral_type_coeffs = dihedral_coeffs , improper_type_coeffs = improper_coeffs , atom_type_labels = atom_type_labels , groups = groups , cell = cell )","title":"load_lmpdat()"},{"location":"reference/atoms/#mofun.atoms.Atoms.replicate","text":"Replicate atoms object across xyz dimensions Warnings: only works for orthorhombic at the moment! does not magically handle any bonds that may cross periodic boundary conditions! Parameters: Name Type Description Default repldims Tuple(int, int, int number of times to replicate in each dimension (1, 1, 1) Returns: Type Description Atoms replicated atoms. Source code in mofun/atoms.py def replicate ( self , repldims = ( 1 , 1 , 1 )): \"\"\"Replicate atoms object across xyz dimensions Warnings: * only works for orthorhombic at the moment! * does not magically handle any bonds that may cross periodic boundary conditions! Args: repldims (Tuple(int, int, int)): number of times to replicate in each dimension Returns: Atoms: replicated atoms. \"\"\" repl_atoms = self . copy () ucmults = np . array ( np . meshgrid ( * [ range ( r ) for r in repldims ])) . T . reshape ( - 1 , 3 ) ucmults = ucmults [ np . any ( ucmults != 0 , axis = 1 )] # remove [0,0,0] since in copy for ucmult in ucmults : transatoms = self . copy () transatoms . translate ( np . matmul ( transatoms . cell , ucmult )) repl_atoms . extend ( transatoms , offsets = ( 0 , 0 , 0 , 0 )) repl_atoms . cell = self . cell * repldims return repl_atoms","title":"replicate()"},{"location":"reference/atoms/#mofun.atoms.Atoms.save","text":"Saves an Atoms object to either a path or a file object and filetype. Can save any of the supported types: lammps data file: \"lmpdat\" mol Parameters: Name Type Description Default f Str or Path or File either a path to a file or an open File to save to required filetype Str filetype ('lmpdat', 'cif', or 'cml') of passed f File object, or explicit filetype to override default filetype implied from file extension. None kwargs keyword args passed on to individual save functions. {} Source code in mofun/atoms.py def save ( self , f , filetype = None , ** kwargs ): \"\"\"Saves an Atoms object to either a path or a file object and filetype. Can save any of the supported types: - lammps data file: \"lmpdat\" - mol Args: f (Str or Path or File): either a path to a file or an open File to save to filetype (Str): filetype ('lmpdat', 'cif', or 'cml') of passed f File object, or explicit filetype to override default filetype implied from file extension. kwargs: keyword args passed on to individual save functions. \"\"\" fd = None path = None if isinstance ( f , io . TextIOBase ): fd = f if filetype is None : raise Exception ( \"If a File object is passed, a filetype must be passed with it\" ) else : # other cases are treated as either Pathlib path or strings path = f if filetype is None : _ , filetype = os . path . splitext ( path ) filetype = filetype [ 1 :] if filetype == \"lmpdat\" : with use_or_open ( fd , path , mode = 'w' ) as fh : atoms = self . save_lmpdat ( fh , ** kwargs ) return atoms elif filetype == \"mol\" : with use_or_open ( fd , path , mode = 'w' ) as fh : return self . save_mol ( fh , ** kwargs ) else : raise Exception ( \"Unsupported filetype\" )","title":"save()"},{"location":"reference/atoms/#mofun.atoms.Atoms.save_lmpdat","text":"Saves a lmpdat file Parameters: Name Type Description Default f File an open file to write to required atom_format str LAMMPS atom format. Supports only 'atomic' and 'full'. 'full' file_comment str written in first line of output file. '' Source code in mofun/atoms.py def save_lmpdat ( self , f , atom_format = \"full\" , file_comment = \"\" ): \"\"\"Saves a lmpdat file Args: f (File): an open file to write to atom_format (str): LAMMPS atom format. Supports only 'atomic' and 'full'. file_comment (str): written in first line of output file. \"\"\" f . write ( \" %s (written by mofun) \\n\\n \" % file_comment ) f . write ( ' %d atoms \\n ' % len ( self . atom_types )) f . write ( ' %d bonds \\n ' % len ( self . bond_types )) f . write ( ' %d angles \\n ' % len ( self . angle_types )) f . write ( ' %d dihedrals \\n ' % len ( self . dihedral_types )) f . write ( ' %d impropers \\n ' % len ( self . improper_types )) f . write ( \" \\n \" ) if self . num_atom_types > 0 : f . write ( ' %d atom types \\n ' % self . num_atom_types ) if self . num_bond_types > 0 : f . write ( ' %d bond types \\n ' % self . num_bond_types ) if self . num_angle_types > 0 : f . write ( ' %d angle types \\n ' % self . num_angle_types ) if self . num_dihedral_types > 0 : f . write ( ' %d dihedral types \\n ' % self . num_dihedral_types ) if self . num_improper_types > 0 : f . write ( ' %d improper types \\n ' % self . num_improper_types ) if self . cell . shape == ( 3 , 3 ): xlohi , ylohi , zlohi = zip ([ 0 , 0 , 0 ], np . diag ( self . cell )) f . write ( \" %10.6f %10.6f xlo xhi \\n \" % xlohi ) f . write ( \" %10.6f %10.6f ylo yhi \\n \" % ylohi ) f . write ( \" %10.6f %10.6f zlo zhi \\n \" % zlohi ) f . write ( \" \\n Masses \\n\\n \" ) for i , m in enumerate ( self . atom_type_masses ): f . write ( \" %d %10.6f # %s \\n \" % ( i + 1 , m , self . label_atoms ( i ))) if len ( self . pair_coeffs ) > 0 : f . write ( ' \\n Pair Coeffs \\n\\n ' ) for i , coeffs in enumerate ( self . pair_coeffs ): f . write ( ' %d %s \\n ' % ( i + 1 , coeffs )) if len ( self . bond_type_coeffs ) > 0 : f . write ( ' \\n Bond Coeffs \\n\\n ' ) for i , coeffs in enumerate ( self . bond_type_coeffs ): f . write ( ' %d %s \\n ' % ( i + 1 , coeffs )) if len ( self . angle_type_coeffs ) > 0 : f . write ( ' \\n Angle Coeffs \\n\\n ' ) for i , coeffs in enumerate ( self . angle_type_coeffs ): f . write ( ' %d %s \\n ' % ( i + 1 , coeffs )) if len ( self . dihedral_type_coeffs ) > 0 : f . write ( ' \\n Dihedral Coeffs \\n\\n ' ) for i , coeffs in enumerate ( self . dihedral_type_coeffs ): f . write ( ' %d %s \\n ' % ( i + 1 , coeffs )) if len ( self . improper_type_coeffs ) > 0 : f . write ( ' \\n Improper Coeffs \\n\\n ' ) for i , coeffs in enumerate ( self . improper_type_coeffs ): f . write ( ' %d %s \\n ' % ( i + 1 , coeffs )) f . write ( \" \\n Atoms \\n\\n \" ) if atom_format == \"atomic\" : for i , ( x , y , z ) in enumerate ( self . positions ): f . write ( \" %d %d %10.6f %10.6f %10.6f # %s \\n \" % ( i + 1 , self . atom_types [ i ] + 1 , x , y , z , self . label_atoms ( self . atom_types [ i ]))) elif atom_format == \"full\" : for i , ( x , y , z ) in enumerate ( self . positions ): f . write ( \" %d %d %d %10.6f %10.6f %10.6f %10.6f # %s \\n \" % ( i + 1 , self . groups [ i ] + 1 , self . atom_types [ i ] + 1 , self . charges [ i ], x , y , z , self . label_atoms ( self . atom_types [ i ]))) if len ( self . bonds ) > 0 : f . write ( \" \\n Bonds \\n\\n \" ) for i , tup in enumerate ( self . bonds ): f . write ( \" %d %d %d %d # %s \\n \" % ( i + 1 , self . bond_types [ i ] + 1 , * ( np . array ( tup ) + 1 ), self . label_atoms ( tup , atom_indices = True ))) if len ( self . angles ) > 0 : f . write ( \" \\n Angles \\n\\n \" ) for i , tup in enumerate ( self . angles ): f . write ( \" %d %d %d %d %d # %s \\n \" % ( i + 1 , self . angle_types [ i ] + 1 , * ( np . array ( tup ) + 1 ), self . label_atoms ( tup , atom_indices = True ))) if len ( self . dihedrals ) > 0 : f . write ( \" \\n Dihedrals \\n\\n \" ) for i , tup in enumerate ( self . dihedrals ): f . write ( \" %d %d %d %d %d %d # %s \\n \" % ( i + 1 , self . dihedral_types [ i ] + 1 , * ( np . array ( tup ) + 1 ), self . label_atoms ( tup , atom_indices = True ))) if len ( self . impropers ) > 0 : f . write ( \" \\n Impropers \\n\\n \" ) for i , tup in enumerate ( self . impropers ): f . write ( \" %d %d %d %d %d %d # %s \\n \" % ( i + 1 , self . improper_types [ i ] + 1 , * ( np . array ( tup ) + 1 ), self . label_atoms ( tup , atom_indices = True )))","title":"save_lmpdat()"},{"location":"reference/atoms/#mofun.atoms.Atoms.save_mol","text":"Writes .mol file for structural information. Source code in mofun/atoms.py def save_mol ( self , f , file_comment = \"\" ): \"\"\"Writes .mol file for structural information.\"\"\" f . write ( \" Molecule_name: %s \\n \" % file_comment ) f . write ( \" \\n \" ) f . write ( \" Coord_Info: Listed Cartesian None \\n \" ) f . write ( \" %d \\n \" % len ( self )) for i , ( x , y , z ) in enumerate ( self . positions ): f . write ( \" %6d %10.4f %10.4f %10.4f %5s %10.8f 0 0 \\n \" % ( i + 1 , x , y , z , self . elements [ i ], self . charges [ i ])) f . write ( \" \\n\\n\\n \" ) f . write ( \" Fundcell_Info: Listed \\n \" ) f . write ( \" %10.4f %10.4f %10.4f \\n \" % tuple ( np . diag ( self . cell ))) f . write ( \" 90.0000 90.0000 90.0000 \\n \" ) f . write ( \" 0.00000 0.00000 0.00000 \\n \" ) f . write ( \" %10.4f %10.4f %10.4f \\n \" % tuple ( np . diag ( self . cell )))","title":"save_mol()"},{"location":"reference/atoms/#mofun.atoms.Atoms.to_ase","text":"Convert to ASE atoms object. Only supports export of the positions and elements. Source code in mofun/atoms.py def to_ase ( self ): \"\"\"Convert to ASE atoms object. Only supports export of the positions and elements. \"\"\" kwargs = dict ( positions = self . positions ) if self . cell is not None and len ( self . cell ) > 0 : kwargs [ 'cell' ] = self . cell return ase . Atoms ( self . elements , ** kwargs )","title":"to_ase()"},{"location":"reference/atoms/#mofun.atoms.find_unchanged_atom_pairs","text":"Returns array of tuple pairs, where each pair contains the indices in the original and the final structure that match. Does not work across PBCs. Source code in mofun/atoms.py def find_unchanged_atom_pairs ( orig_structure , final_structure , max_delta = 1e-5 ): \"\"\"Returns array of tuple pairs, where each pair contains the indices in the original and the final structure that match. Does not work across PBCs.\"\"\" match_pairs = [] for i , p1 in enumerate ( orig_structure . positions ): for j , p2 in enumerate ( final_structure . positions ): if norm ( np . array ( p2 ) - p1 ) < max_delta and orig_structure . elements [ i ] == final_structure . elements [ j ]: match_pairs . append (( i , j )) break return match_pairs","title":"find_unchanged_atom_pairs()"},{"location":"reference/mofun/","text":"find_pattern_in_structure ( structure , pattern , return_positions = False , rel_tol = 0.05 , verbose = False ) Looks for instances of pattern in structure , where a match in the structure has the same number of atoms, the same elements and the same relative coordinates as in pattern . Returns a list of tuples, one tuple per match found in structure where each tuple has the size len(pattern) and contains the indices in the structure that matched the pattern. If return_postions=True then an additional list is returned containing positions for each matched index for each match. Parameters: Name Type Description Default structure Atoms an Atoms object to search in. required pattern Atoms an Atoms object to search for. required return_positions bool additionally returns the positions for each index False rel_tol float the relative tolerance (how close an atom must be in the structure to the position in pattern to be consdired a match). 0.05 verbose bool print debugging info. False Returns: Type Description List [tuple(len(pattern))] returns a tuple of size len(pattern) containing the indices in structure that matched the pattern, one tuple per each match. Source code in mofun/mofun.py def find_pattern_in_structure ( structure , pattern , return_positions = False , rel_tol = 5e-2 , verbose = False ): \"\"\"Looks for instances of `pattern` in `structure`, where a match in the structure has the same number of atoms, the same elements and the same relative coordinates as in `pattern`. Returns a list of tuples, one tuple per match found in `structure` where each tuple has the size `len(pattern)` and contains the indices in the structure that matched the pattern. If `return_postions=True` then an additional list is returned containing positions for each matched index for each match. Args: structure (Atoms): an Atoms object to search in. pattern (Atoms): an Atoms object to search for. return_positions (bool): additionally returns the positions for each index rel_tol (float): the relative tolerance (how close an atom must be in the structure to the position in pattern to be consdired a match). verbose (bool): print debugging info. Returns: List [tuple(len(pattern))]: returns a tuple of size `len(pattern)` containing the indices in structure that matched the pattern, one tuple per each match. \"\"\" # the relative tolerance needs adjusted to squared relative tolerance rel_tol_sq = 1 - ( 1 - rel_tol ) ** 2 if verbose : print ( \"calculating point distances...\" ) p_ss = distance . cdist ( pattern . positions , pattern . positions , \"sqeuclidean\" ) s_types_view , s_ss , index_mapper , s_positions = get_types_ss_map_limited_near_uc ( structure , p_ss . max () ** 0.5 , structure . cell ) atoms_by_type = atoms_by_type_dict ( s_types_view ) for i in range ( len ( pattern )): # Search instances of first atom in a search pattern if i == 0 : # 0,0,0 uc atoms are always indexed first from 0 to # atoms in structure. match_index_tuples = [[ idx ] for idx in atoms_of_type ( s_types_view [ 0 : len ( structure )], pattern . elements [ 0 ])] if verbose : print ( \"round %d ( %d ) [ %s ]: \" % ( i , len ( match_index_tuples ), pattern . elements [ 0 ]), match_index_tuples ) continue last_match_index_tuples = match_index_tuples match_index_tuples = [] for match in last_match_index_tuples : for atom_idx in atoms_by_type [ pattern . elements [ i ]]: found_match = True for j in range ( i ): if not math . isclose ( p_ss [ i , j ], s_ss [ match [ j ], atom_idx ], rel_tol = rel_tol_sq ): found_match = False break # anything that matches the distance to all prior pattern atoms is a good match so far if found_match : match_index_tuples . append ( match + [ atom_idx ]) if verbose : print ( \"round %d ( %d ) [ %s ]: \" % ( i , len ( match_index_tuples ), pattern . elements [ i ]), match_index_tuples ) match_index_tuples = remove_duplicates ( match_index_tuples , key = lambda m : tuple ( sorted ([ index_mapper [ i ] % len ( structure ) for i in m ]))) match_index_tuples_in_uc = [ tuple ([ index_mapper [ m ] % len ( structure ) for m in match ]) for match in match_index_tuples ] if return_positions : match_index_tuple_positions = np . array ([[ s_positions [ index_mapper [ m ]] for m in match ] for match in match_index_tuples ]) return match_index_tuples_in_uc , match_index_tuple_positions else : return match_index_tuples_in_uc get_types_ss_map_limited_near_uc ( structure , length , cell ) structure: length: the length of the longest dimension of the search pattern cell: creates master lists of indices, types and positions, for all atoms in the structure and all atoms across the PBCs. Limits atoms across PBCs to those that are within a distance of the boundary that is less than the length of the search pattern (i.e. atoms further away from the boundary than this will never match the search pattern). Source code in mofun/mofun.py def get_types_ss_map_limited_near_uc ( structure , length , cell ): \"\"\" structure: length: the length of the longest dimension of the search pattern cell: creates master lists of indices, types and positions, for all atoms in the structure and all atoms across the PBCs. Limits atoms across PBCs to those that are within a distance of the boundary that is less than the length of the search pattern (i.e. atoms further away from the boundary than this will never match the search pattern). \"\"\" # if not (cell.angles() == [90., 90., 90.]).all(): # raise Exception(\"Currently optimizations do not support unit cell angles != 90\") uc_offsets = uc_neighbor_offsets ( structure . cell ) # move (0., 0., 0.) to be at the 0 index uc_offsets [ np . where ( np . all ( uc_offsets == ( 0 , 0 , 0 ), axis = 1 ))[ 0 ][ 0 ]] = uc_offsets [ 0 ] uc_offsets [ 0 ] = ( 0.0 , 0.0 , 0.0 ) s_positions = [ structure . positions + uc_offset for uc_offset in uc_offsets ] s_positions = np . array ([ x for y in s_positions for x in y ]) s_types = list ( structure . elements ) * len ( uc_offsets ) cell = list ( np . diag ( cell )) index_mapper = [] s_pos_view = [] s_types_view = [] for i , pos in enumerate ( s_positions ): # only currently works for orthorhombic crystals if ( pos [ 0 ] >= - length and pos [ 0 ] < length + cell [ 0 ] and pos [ 1 ] >= - length and pos [ 1 ] < length + cell [ 1 ] and pos [ 2 ] >= - length and pos [ 2 ] < length + cell [ 2 ]): index_mapper . append ( i ) s_pos_view . append ( pos ) s_types_view . append ( s_types [ i ]) s_ss = distance . cdist ( s_pos_view , s_pos_view , \"sqeuclidean\" ) return s_types_view , s_ss , index_mapper , s_positions replace_pattern_in_structure ( structure , search_pattern , replace_pattern , replace_fraction = 1.0 , axis1a_idx = 0 , axis1b_idx =- 1 , verbose = False ) Replaces all instances of pattern in structure with the replace_pattern . Works across periodic boundary conditions. WARNING: the replace pattern MUST be on the same coordinate system as the search_pattern. If there are atoms that remain the same between the search and replace patterns, they must have the exact same coordinates. If these were to be offset, or moved, then when the replacement pattern gets inserted into the structure, then the replacement will also be offset. Parameters: Name Type Description Default structure Atoms an Atoms object to search in. required search_pattern Atoms an Atoms object to search for. required replace_pattern Atoms an Atoms object to search for. required replace_fraction float how many instances of the search_pattern found in the structure get replaced by the replace pattern. 1.0 axis1a_idx float index in search_pattern of first point defining the directional axis of the search_pattern. Mostly useful for testing and debugging. 0 axis1b_idx float index in search_pattern of second point defining the directional axis of the search_pattern. Mostly useful for testing and debugging. -1 verbose bool print debugging info. False Returns: Type Description Atoms the structure after search_pattern is replaced by replace_pattern. Source code in mofun/mofun.py def replace_pattern_in_structure ( structure , search_pattern , replace_pattern , replace_fraction = 1.0 , axis1a_idx = 0 , axis1b_idx =- 1 , verbose = False ): \"\"\"Replaces all instances of `pattern` in `structure` with the `replace_pattern`. Works across periodic boundary conditions. WARNING: the replace pattern _MUST_ be on the same coordinate system as the search_pattern. If there are atoms that remain the same between the search and replace patterns, they must have the exact same coordinates. If these were to be offset, or moved, then when the replacement pattern gets inserted into the structure, then the replacement will also be offset. Args: structure (Atoms): an Atoms object to search in. search_pattern (Atoms): an Atoms object to search for. replace_pattern (Atoms): an Atoms object to search for. replace_fraction (float): how many instances of the search_pattern found in the structure get replaced by the replace pattern. axis1a_idx (float): index in search_pattern of first point defining the directional axis of the search_pattern. Mostly useful for testing and debugging. axis1b_idx (float): index in search_pattern of second point defining the directional axis of the search_pattern. Mostly useful for testing and debugging. verbose (bool): print debugging info. Returns: Atoms: the structure after search_pattern is replaced by replace_pattern. \"\"\" search_pattern = search_pattern . copy () replace_pattern = replace_pattern . copy () match_indices , match_positions = find_pattern_in_structure ( structure , search_pattern , return_positions = True ) if replace_fraction < 1.0 : replace_indices = random . sample ( list ( range ( len ( match_positions ))), k = round ( replace_fraction * len ( match_positions ))) match_indices = [ match_indices [ i ] for i in replace_indices ] match_positions = match_positions [ replace_indices ] if verbose : print ( match_indices , match_positions ) # translate both search and replace patterns so that first atom of search pattern is at the origin replace_pattern . translate ( - search_pattern . positions [ axis1a_idx ]) search_pattern . translate ( - search_pattern . positions [ axis1a_idx ]) search_axis = search_pattern . positions [ axis1b_idx ] if verbose : print ( \"search_axis: \" , search_axis ) replace2search_pattern_map = { k : v for ( k , v ) in find_unchanged_atom_pairs ( replace_pattern , search_pattern )} if len ( search_pattern ) > 2 : orientation_point_index = position_index_farthest_from_axis ( search_axis , search_pattern ) orientation_point = search_pattern . positions [ orientation_point_index ] orientation_axis = orientation_point - ( np . dot ( orientation_point , search_axis ) / np . dot ( search_axis , search_axis )) * search_axis if verbose : print ( \"orientation_axis: \" , orientation_axis ) new_structure = structure . copy () to_delete = set () if len ( replace_pattern ) == 0 : to_delete |= set ([ idx for match in match_indices for idx in match ]) else : offsets = new_structure . extend_types ( replace_pattern ) for m_i , atom_positions in enumerate ( match_positions ): new_atoms = replace_pattern . copy () if verbose : print ( atom_positions ) print ( \"--------------\" ) print ( \"original atoms: \\n \" , atom_positions ) print ( \"new atoms: \\n \" , new_atoms . positions ) if len ( atom_positions ) > 1 : found_axis = atom_positions [ axis1b_idx ] - atom_positions [ axis1a_idx ] if verbose : print ( \"found axis: \" , found_axis ) q1 = quaternion_from_two_vectors ( search_axis , found_axis ) if q1 is not None : new_atoms . positions = q1 . apply ( new_atoms . positions ) if verbose : print ( \"q1: \" , q1 . as_quat ()) print ( \"new atoms after q1: \\n \" , new_atoms . positions ) print ( \"new atoms after q1 (translated): \\n \" , new_atoms . positions + atom_positions [ axis1a_idx ]) if len ( atom_positions ) > 2 : found_orientation_point = atom_positions [ orientation_point_index ] - atom_positions [ axis1a_idx ] found_orientation_axis = found_orientation_point - ( np . dot ( found_orientation_point , found_axis ) / np . dot ( found_axis , found_axis )) * found_axis if verbose : print ( \"found orientation_axis: \" , found_orientation_axis ) q1_o_axis = orientation_axis if q1 is not None : q1_o_axis = q1 . apply ( q1_o_axis ) q2 = quaternion_from_two_vectors_around_axis ( found_orientation_axis , q1_o_axis , found_axis ) if verbose : print ( \"(transformed) orientation_axis: \" , q1_o_axis ) print ( \"orienting: \" , found_orientation_point , q1_o_axis , found_orientation_axis , q2 ) if q2 is not None : new_atoms . positions = q2 . apply ( new_atoms . positions ) if verbose : print ( \"q2: \" , q2 . as_quat ()) print ( \"new aif verbose: toms after q2: \\n \" , new_atoms . positions ) # move replacement atoms into correct position new_atoms . translate ( atom_positions [ axis1a_idx ]) new_atoms . positions %= np . diag ( new_structure . cell ) if verbose : print ( \"new atoms after translate: \\n \" , new_atoms . positions ) structure_index_map = { k : match_indices [ m_i ][ v ] for k , v in replace2search_pattern_map . items ()} new_structure . extend ( new_atoms , offsets = offsets , structure_index_map = structure_index_map ) to_delete_linker = set ( match_indices [ m_i ]) - set ( structure_index_map . values ()) to_delete |= set ( to_delete_linker ) del ( new_structure [ list ( to_delete )]) return new_structure","title":"Mofun"},{"location":"reference/mofun/#mofun.mofun.find_pattern_in_structure","text":"Looks for instances of pattern in structure , where a match in the structure has the same number of atoms, the same elements and the same relative coordinates as in pattern . Returns a list of tuples, one tuple per match found in structure where each tuple has the size len(pattern) and contains the indices in the structure that matched the pattern. If return_postions=True then an additional list is returned containing positions for each matched index for each match. Parameters: Name Type Description Default structure Atoms an Atoms object to search in. required pattern Atoms an Atoms object to search for. required return_positions bool additionally returns the positions for each index False rel_tol float the relative tolerance (how close an atom must be in the structure to the position in pattern to be consdired a match). 0.05 verbose bool print debugging info. False Returns: Type Description List [tuple(len(pattern))] returns a tuple of size len(pattern) containing the indices in structure that matched the pattern, one tuple per each match. Source code in mofun/mofun.py def find_pattern_in_structure ( structure , pattern , return_positions = False , rel_tol = 5e-2 , verbose = False ): \"\"\"Looks for instances of `pattern` in `structure`, where a match in the structure has the same number of atoms, the same elements and the same relative coordinates as in `pattern`. Returns a list of tuples, one tuple per match found in `structure` where each tuple has the size `len(pattern)` and contains the indices in the structure that matched the pattern. If `return_postions=True` then an additional list is returned containing positions for each matched index for each match. Args: structure (Atoms): an Atoms object to search in. pattern (Atoms): an Atoms object to search for. return_positions (bool): additionally returns the positions for each index rel_tol (float): the relative tolerance (how close an atom must be in the structure to the position in pattern to be consdired a match). verbose (bool): print debugging info. Returns: List [tuple(len(pattern))]: returns a tuple of size `len(pattern)` containing the indices in structure that matched the pattern, one tuple per each match. \"\"\" # the relative tolerance needs adjusted to squared relative tolerance rel_tol_sq = 1 - ( 1 - rel_tol ) ** 2 if verbose : print ( \"calculating point distances...\" ) p_ss = distance . cdist ( pattern . positions , pattern . positions , \"sqeuclidean\" ) s_types_view , s_ss , index_mapper , s_positions = get_types_ss_map_limited_near_uc ( structure , p_ss . max () ** 0.5 , structure . cell ) atoms_by_type = atoms_by_type_dict ( s_types_view ) for i in range ( len ( pattern )): # Search instances of first atom in a search pattern if i == 0 : # 0,0,0 uc atoms are always indexed first from 0 to # atoms in structure. match_index_tuples = [[ idx ] for idx in atoms_of_type ( s_types_view [ 0 : len ( structure )], pattern . elements [ 0 ])] if verbose : print ( \"round %d ( %d ) [ %s ]: \" % ( i , len ( match_index_tuples ), pattern . elements [ 0 ]), match_index_tuples ) continue last_match_index_tuples = match_index_tuples match_index_tuples = [] for match in last_match_index_tuples : for atom_idx in atoms_by_type [ pattern . elements [ i ]]: found_match = True for j in range ( i ): if not math . isclose ( p_ss [ i , j ], s_ss [ match [ j ], atom_idx ], rel_tol = rel_tol_sq ): found_match = False break # anything that matches the distance to all prior pattern atoms is a good match so far if found_match : match_index_tuples . append ( match + [ atom_idx ]) if verbose : print ( \"round %d ( %d ) [ %s ]: \" % ( i , len ( match_index_tuples ), pattern . elements [ i ]), match_index_tuples ) match_index_tuples = remove_duplicates ( match_index_tuples , key = lambda m : tuple ( sorted ([ index_mapper [ i ] % len ( structure ) for i in m ]))) match_index_tuples_in_uc = [ tuple ([ index_mapper [ m ] % len ( structure ) for m in match ]) for match in match_index_tuples ] if return_positions : match_index_tuple_positions = np . array ([[ s_positions [ index_mapper [ m ]] for m in match ] for match in match_index_tuples ]) return match_index_tuples_in_uc , match_index_tuple_positions else : return match_index_tuples_in_uc","title":"find_pattern_in_structure()"},{"location":"reference/mofun/#mofun.mofun.get_types_ss_map_limited_near_uc","text":"structure: length: the length of the longest dimension of the search pattern cell: creates master lists of indices, types and positions, for all atoms in the structure and all atoms across the PBCs. Limits atoms across PBCs to those that are within a distance of the boundary that is less than the length of the search pattern (i.e. atoms further away from the boundary than this will never match the search pattern). Source code in mofun/mofun.py def get_types_ss_map_limited_near_uc ( structure , length , cell ): \"\"\" structure: length: the length of the longest dimension of the search pattern cell: creates master lists of indices, types and positions, for all atoms in the structure and all atoms across the PBCs. Limits atoms across PBCs to those that are within a distance of the boundary that is less than the length of the search pattern (i.e. atoms further away from the boundary than this will never match the search pattern). \"\"\" # if not (cell.angles() == [90., 90., 90.]).all(): # raise Exception(\"Currently optimizations do not support unit cell angles != 90\") uc_offsets = uc_neighbor_offsets ( structure . cell ) # move (0., 0., 0.) to be at the 0 index uc_offsets [ np . where ( np . all ( uc_offsets == ( 0 , 0 , 0 ), axis = 1 ))[ 0 ][ 0 ]] = uc_offsets [ 0 ] uc_offsets [ 0 ] = ( 0.0 , 0.0 , 0.0 ) s_positions = [ structure . positions + uc_offset for uc_offset in uc_offsets ] s_positions = np . array ([ x for y in s_positions for x in y ]) s_types = list ( structure . elements ) * len ( uc_offsets ) cell = list ( np . diag ( cell )) index_mapper = [] s_pos_view = [] s_types_view = [] for i , pos in enumerate ( s_positions ): # only currently works for orthorhombic crystals if ( pos [ 0 ] >= - length and pos [ 0 ] < length + cell [ 0 ] and pos [ 1 ] >= - length and pos [ 1 ] < length + cell [ 1 ] and pos [ 2 ] >= - length and pos [ 2 ] < length + cell [ 2 ]): index_mapper . append ( i ) s_pos_view . append ( pos ) s_types_view . append ( s_types [ i ]) s_ss = distance . cdist ( s_pos_view , s_pos_view , \"sqeuclidean\" ) return s_types_view , s_ss , index_mapper , s_positions","title":"get_types_ss_map_limited_near_uc()"},{"location":"reference/mofun/#mofun.mofun.replace_pattern_in_structure","text":"Replaces all instances of pattern in structure with the replace_pattern . Works across periodic boundary conditions. WARNING: the replace pattern MUST be on the same coordinate system as the search_pattern. If there are atoms that remain the same between the search and replace patterns, they must have the exact same coordinates. If these were to be offset, or moved, then when the replacement pattern gets inserted into the structure, then the replacement will also be offset. Parameters: Name Type Description Default structure Atoms an Atoms object to search in. required search_pattern Atoms an Atoms object to search for. required replace_pattern Atoms an Atoms object to search for. required replace_fraction float how many instances of the search_pattern found in the structure get replaced by the replace pattern. 1.0 axis1a_idx float index in search_pattern of first point defining the directional axis of the search_pattern. Mostly useful for testing and debugging. 0 axis1b_idx float index in search_pattern of second point defining the directional axis of the search_pattern. Mostly useful for testing and debugging. -1 verbose bool print debugging info. False Returns: Type Description Atoms the structure after search_pattern is replaced by replace_pattern. Source code in mofun/mofun.py def replace_pattern_in_structure ( structure , search_pattern , replace_pattern , replace_fraction = 1.0 , axis1a_idx = 0 , axis1b_idx =- 1 , verbose = False ): \"\"\"Replaces all instances of `pattern` in `structure` with the `replace_pattern`. Works across periodic boundary conditions. WARNING: the replace pattern _MUST_ be on the same coordinate system as the search_pattern. If there are atoms that remain the same between the search and replace patterns, they must have the exact same coordinates. If these were to be offset, or moved, then when the replacement pattern gets inserted into the structure, then the replacement will also be offset. Args: structure (Atoms): an Atoms object to search in. search_pattern (Atoms): an Atoms object to search for. replace_pattern (Atoms): an Atoms object to search for. replace_fraction (float): how many instances of the search_pattern found in the structure get replaced by the replace pattern. axis1a_idx (float): index in search_pattern of first point defining the directional axis of the search_pattern. Mostly useful for testing and debugging. axis1b_idx (float): index in search_pattern of second point defining the directional axis of the search_pattern. Mostly useful for testing and debugging. verbose (bool): print debugging info. Returns: Atoms: the structure after search_pattern is replaced by replace_pattern. \"\"\" search_pattern = search_pattern . copy () replace_pattern = replace_pattern . copy () match_indices , match_positions = find_pattern_in_structure ( structure , search_pattern , return_positions = True ) if replace_fraction < 1.0 : replace_indices = random . sample ( list ( range ( len ( match_positions ))), k = round ( replace_fraction * len ( match_positions ))) match_indices = [ match_indices [ i ] for i in replace_indices ] match_positions = match_positions [ replace_indices ] if verbose : print ( match_indices , match_positions ) # translate both search and replace patterns so that first atom of search pattern is at the origin replace_pattern . translate ( - search_pattern . positions [ axis1a_idx ]) search_pattern . translate ( - search_pattern . positions [ axis1a_idx ]) search_axis = search_pattern . positions [ axis1b_idx ] if verbose : print ( \"search_axis: \" , search_axis ) replace2search_pattern_map = { k : v for ( k , v ) in find_unchanged_atom_pairs ( replace_pattern , search_pattern )} if len ( search_pattern ) > 2 : orientation_point_index = position_index_farthest_from_axis ( search_axis , search_pattern ) orientation_point = search_pattern . positions [ orientation_point_index ] orientation_axis = orientation_point - ( np . dot ( orientation_point , search_axis ) / np . dot ( search_axis , search_axis )) * search_axis if verbose : print ( \"orientation_axis: \" , orientation_axis ) new_structure = structure . copy () to_delete = set () if len ( replace_pattern ) == 0 : to_delete |= set ([ idx for match in match_indices for idx in match ]) else : offsets = new_structure . extend_types ( replace_pattern ) for m_i , atom_positions in enumerate ( match_positions ): new_atoms = replace_pattern . copy () if verbose : print ( atom_positions ) print ( \"--------------\" ) print ( \"original atoms: \\n \" , atom_positions ) print ( \"new atoms: \\n \" , new_atoms . positions ) if len ( atom_positions ) > 1 : found_axis = atom_positions [ axis1b_idx ] - atom_positions [ axis1a_idx ] if verbose : print ( \"found axis: \" , found_axis ) q1 = quaternion_from_two_vectors ( search_axis , found_axis ) if q1 is not None : new_atoms . positions = q1 . apply ( new_atoms . positions ) if verbose : print ( \"q1: \" , q1 . as_quat ()) print ( \"new atoms after q1: \\n \" , new_atoms . positions ) print ( \"new atoms after q1 (translated): \\n \" , new_atoms . positions + atom_positions [ axis1a_idx ]) if len ( atom_positions ) > 2 : found_orientation_point = atom_positions [ orientation_point_index ] - atom_positions [ axis1a_idx ] found_orientation_axis = found_orientation_point - ( np . dot ( found_orientation_point , found_axis ) / np . dot ( found_axis , found_axis )) * found_axis if verbose : print ( \"found orientation_axis: \" , found_orientation_axis ) q1_o_axis = orientation_axis if q1 is not None : q1_o_axis = q1 . apply ( q1_o_axis ) q2 = quaternion_from_two_vectors_around_axis ( found_orientation_axis , q1_o_axis , found_axis ) if verbose : print ( \"(transformed) orientation_axis: \" , q1_o_axis ) print ( \"orienting: \" , found_orientation_point , q1_o_axis , found_orientation_axis , q2 ) if q2 is not None : new_atoms . positions = q2 . apply ( new_atoms . positions ) if verbose : print ( \"q2: \" , q2 . as_quat ()) print ( \"new aif verbose: toms after q2: \\n \" , new_atoms . positions ) # move replacement atoms into correct position new_atoms . translate ( atom_positions [ axis1a_idx ]) new_atoms . positions %= np . diag ( new_structure . cell ) if verbose : print ( \"new atoms after translate: \\n \" , new_atoms . positions ) structure_index_map = { k : match_indices [ m_i ][ v ] for k , v in replace2search_pattern_map . items ()} new_structure . extend ( new_atoms , offsets = offsets , structure_index_map = structure_index_map ) to_delete_linker = set ( match_indices [ m_i ]) - set ( structure_index_map . values ()) to_delete |= set ( to_delete_linker ) del ( new_structure [ list ( to_delete )]) return new_structure","title":"replace_pattern_in_structure()"}]}